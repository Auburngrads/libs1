---
title: "`r SMRD:::info('book')`"
subtitle: "`r SMRD:::info('chapter16')`"
author: "`r SMRD:::info('authors')`"
date: "`r format(Sys.Date(), '%d %B %Y')`"
output:
  slidy_presentation:
    smart: false
    fig_caption: yes
footer: "`r paste('SMRD: ', SMRD:::info('chapter16'))`"
runtime: shiny
graphics: yes
---

```{r intro, echo=FALSE,message=FALSE, warning=FALSE}
source(jkf::SCRIPT('setup.R'))
```

# CHAPTER OVERVIEW

```{r}
shiny::includeCSS(jkf::SCRIPT('flat-slidy.css'))
shiny::includeScript(jkf::SCRIPT("jquery.min.js"))
shiny::includeScript(jkf::SCRIPT("jkf-scroll.js"))
```

## This chapter explains

- Typical data from repairable systems and other applications that have recurrence data

- Simple nonparametric graphical methods for presenting recurrence data

- Simple parametric models for recurrence data

- The combined use of simple parametric and nonparametric graphical methods for drawing conclusions from recurrence data

- A method of simulating recurrence data

- Some basic ideas of software reliability modeling

# Section 16.1|Introduction

# 16.1.1 - Repairable system reliability data and other recurrence data 


# 16.1.2 - A nonparametric model for recurrence data 


# Section 16.2|Nonparametric Estimation of the MCF

# 16.2.1 - Nonparametric model assumptions


# 16.2.2 - Point estimate of the MCF


# 16.2.3 - Standard errors and nonparametric CI for MCF


# 16.2.4 - Adequacy of normal approximation CI


# Section 16.3|Nonparametric Comparison of Two Samples of Recurrence Data

# 16.3 - Nonparametric comparison of two samples of recurrence data


# Section 16.4|Parametric Models for Recurrence Data

# 16.4.1 - Poisson process


# 16.4.2 - Homogeneous Poisson process


# 16.4.3 - Nonhomogeneous Poisson process


# 16.4.4 - Renewal processes


# 16.4.5 - Superimposed renewal processes


# Section 16.5|Tools for Checking Point-Process Assumptions

# 16.5.1 - Tests for recurrence rate trend


# 16.5.2 - Test for independent interocurrence times


# Section 16.6|Maximum Likelihood Fitting of Poisson Process

# 16.6.1 - Poisson process likelihood


# 16.6.2 - Superimposed Poisson process likelihood


# 16.6.3 - ML estimation for the power NHPP


# 16.6.4 - ML estimation for the loglinear NHPP


# 16.6.5 - Confidence intervals for parameters and functions of parameters


# 16.6.6 - Prediction of future recurrences with a Poisson process


# Section 16.7|Generating Pseudorandom Realizations From an NHPP Data

# 16.7.1 - General approach


# 16.7.2 - NHPP with a power recurrence rate


# 16.7.3 - NHPP with a loglinear recurrence rate


# Section 16.8|Software Reliability

# 1.4.1 - Reliability data (non-repairable units)


Graphically, non-repairable systems may be represented by a two-state transition diagram with an absorbing state

- State 0: Initial working state
- State 1: Absorbing failed state

```{r trans-diagram-plot1,echo=FALSE,fig.align='center',message=FALSE}
Mat1 <- matrix(NA, nrow = 2, ncol = 2)

AA <- as.data.frame(Mat1)
AA[[2,1]] <- "F[0:1]"

name <- c(expression(0[Alive]), expression(1[Dead]))

par(family="serif",bg=NA,pin=c(6,4))

diagram::plotmat(A = AA, pos = 2, curve = .575, name = name, lwd = 2,
        arr.len = 0.6, arr.width = 0.25, my = .25,
        box.size = 0.08, arr.type = "triangle", dtext = -1,
        relsize=.99,box.cex=1.5,cex=1.25)
```

# 1.4.2 - Reliability data (repairable systems)


Systems for which cost considerations justify repair rather than replacement

Graphically represented by two or more transient states

```{r repairable-system,echo=FALSE,fig.align='center',message=FALSE}
Mat2 <- matrix(NA, nrow = 3, ncol = 3)

AA <- as.data.frame(Mat2)
AA[[1,2]] <- "F[1:0]"
AA[[1,3]] <- "F[2:0]"
AA[[2,1]] <- "F[0:1]"
AA[[3,1]] <- "F[0:2]"

name <- c(expression(0[Alive]), expression(1[Failed]), expression(2[Failed]))

par(family="serif",bg=NA,pin=c(6,4))

diagram::plotmat(A = AA, pos = 3, curve = .575, name = name, lwd = 2,
        arr.len = 0.6, arr.width = 0.25, my = .05,
        box.size = 0.08, arr.type = "triangle", dtext = -1,
        relsize=.99,box.cex=1.5,cex=1.25)
```

## Repairable vs. non-repairable systems


In truth, most systems are repairable AND non-repariable

Or stated more correctly, most systems have both repairable and non-repairable <font color="red">__failure modes__</font>

```{r trans-diagram-plot,echo=FALSE,fig.align='center',message=FALSE}
DiffMat <- matrix(NA, nrow = 4, ncol = 4)

AA <- as.data.frame(DiffMat)
AA[[1,2]] <- "F[1:0]"
AA[[1,3]] <- "F[2:0]"
AA[[2,1]] <- "F[0:1]"
AA[[3,1]] <- "F[0:2]"
AA[[4,1]] <- "F[0:3]"

name <- c(expression(0[Alive]), expression(1[Failed]), 
          expression(2[Failed]), expression(3[Dead]))

par(family="serif",bg=NA,pin=c(6,4))

diagram::plotmat(A = AA, pos = 4, curve = .575, name = name, lwd = 2,
        arr.len = 0.6, arr.width = 0.25, my = .15,
        box.size = 0.08, arr.type = "triangle", dtext = -1,
        relsize=.99,box.cex=1.5,cex=1.25)
```

# 1.4.2 - Reliability data (repairable systems) 

```{r trans-diagram-code,echo=FALSE,message=FALSE, fig.align='center'}
library(diagram)

DiffMat <- matrix(NA, nrow = 4, ncol = 4)

AA <- as.data.frame(DiffMat)
AA[[2,1]] <- "lambda[1]"
AA[[3,1]] <- "lambda[2]"
AA[[4,2]] <- "lambda[2]"
AA[[4,3]] <- "lambda[1]"

name <- c(0,1,2,3)

par(family="serif",bg=NA, mar = c(0,0,0,0))

diagram::plotmat(A = AA, pos = 4, curve = .575, name = name, lwd = 2,
        arr.len = 0.5, arr.width = 0.25, my = .15,
        box.size = 0.08, dtext = -1,
        relsize=.99,box.cex=1.5,cex=1.25)
```

State | Component 1 Status | Component 2 Status | System Status
------|--------------------|--------------------|--------------
0     | Working            |   Working          | Alive
1     | Failed             |   Working          | Degraded
2     | Working            |   Failed           | Degraded
3     | Failed             |   Failed           | Dead

## Stochastic Processes

Looks at a sequence of events and analyzes the tendency of one event to follow another. Using this analysis, we can generate a new sequence of random but related events, which appear similar to the original. Many random events are affected by what has happened before. For example, today's weather may have an influence on what tomorrow's weather will be. They are not totally independent events.

Markov analysis assumes that the future is independent of the past, given the present. When using Markov the random variable is indexed in time, which can be either discrete or continuous.

## Markov

After observing a long sequence of rainy and sunny days, a Markov model 
could be used to analyze the likelihood that one kind of weather follows another. 
Assume that 25% of the time, a sunny day follows a rainy day and 75% of the time, 
rain was followed by more rain. Also assume that sunny days were followed 50% 
of the time by rain, and 50% by sun.  Using this analysis, one could generate a new sequence of statistically similar

weather patterns by following these steps: 
Given today's weather, choose a random number to pick tomorrow's weather.
Make tomorrow's weather "today's weather" and go back to step 2.
A result is a particular sequence of days as follows: Sunny Sunny Rainy Rainy Rainy Rainy Sunny Rainy Rainy Sunny Sunny...
