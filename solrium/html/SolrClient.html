<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Solr connection client</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for SolrClient {solrium}"><tr><td>SolrClient {solrium}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Solr connection client</h2>

<h3>Description</h3>

<p>Solr connection client
</p>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>host</code></td>
<td>
<p>(character) Host url. Deafault: 127.0.0.1</p>
</td></tr>
<tr valign="top"><td><code>path</code></td>
<td>
<p>(character) url path.</p>
</td></tr>
<tr valign="top"><td><code>port</code></td>
<td>
<p>(character/numeric) Port. Default: 8389</p>
</td></tr>
<tr valign="top"><td><code>scheme</code></td>
<td>
<p>(character) http scheme, one of http or https. Default: http</p>
</td></tr>
<tr valign="top"><td><code>proxy</code></td>
<td>
<p>List of arguments for a proxy connection, including one or
more of: url, port, username, password, and auth. See
<a href="../../crul/html/proxy.html">crul::proxy</a> for  help, which is used to construct the
proxy connection.</p>
</td></tr>
<tr valign="top"><td><code>errors</code></td>
<td>
<p>(character) One of <code>"simple"</code> or <code>"complete"</code>. Simple gives
http code and  error message on an error, while complete gives both http
code and error message, and stack trace, if available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>SolrClient</code> creates a R6 class object. The object is
not cloneable and is portable, so it can be inherited across packages
without complication.
</p>
<p><code>SolrClient</code> is used to initialize a client that knows about your
Solr instance, with options for setting host, port, http scheme,
and simple vs. complete error reporting
</p>


<h3>Value</h3>

<p>Various output, see help files for each grouping of methods.
</p>


<h3>SolrClient methods</h3>

<p>Each of these methods also has a matching standalone exported
function that you can use by passing in the connection object made
by calling <code>SolrClient$new()</code>. Also, see the docs for each method for
parameter definitions and their default values.
</p>

<ul>
<li> <p><code>ping(name, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>schema(name, what = '', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>commit(name, expunge_deletes = FALSE, wait_searcher = TRUE, soft_commit = FALSE, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>optimize(name, max_segments = 1, wait_searcher = TRUE, soft_commit = FALSE, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>config_get(name, what = NULL, wt = "json", raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>config_params(name, param = NULL, set = NULL, unset = NULL, update = NULL, ...)</code>
</p>
</li>
<li> <p><code>config_overlay(name, omitHeader = FALSE, ...)</code>
</p>
</li>
<li> <p><code>config_set(name, set = NULL, unset = NULL, ...)</code>
</p>
</li>
<li> <p><code>collection_exists(name, ...)</code>
</p>
</li>
<li> <p><code>collection_list(raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_create(name, numShards = 1, maxShardsPerNode = 1, createNodeSet = NULL, collection.configName = NULL, replicationFactor = 1, router.name = NULL, shards = NULL, createNodeSet.shuffle = TRUE, router.field = NULL, autoAddReplicas = FALSE, async = NULL, raw = FALSE, callopts=list(), ...)</code>
</p>
</li>
<li> <p><code>collection_addreplica(name, shard = NULL, route = NULL, node = NULL, instanceDir = NULL, dataDir = NULL, async = NULL, raw = FALSE, callopts=list(), ...)</code>
</p>
</li>
<li> <p><code>collection_addreplicaprop(name, shard, replica, property, property.value, shardUnique = FALSE, raw = FALSE, callopts=list())</code>
</p>
</li>
<li> <p><code>collection_addrole(role = "overseer", node, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_balanceshardunique(name, property, onlyactivenodes = TRUE, shardUnique = NULL, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_clusterprop(name, val, raw = FALSE, callopts=list())</code>
</p>
</li>
<li> <p><code>collection_clusterstatus(name = NULL, shard = NULL, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_createalias(alias, collections, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_createshard(name, shard, createNodeSet = NULL, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_delete(name, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_deletealias(alias, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_deletereplica(name, shard = NULL, replica = NULL, onlyIfDown = FALSE, raw = FALSE, callopts=list(), ...)</code>
</p>
</li>
<li> <p><code>collection_deletereplicaprop(name, shard, replica, property, raw = FALSE, callopts=list())</code>
</p>
</li>
<li> <p><code>collection_deleteshard(name, shard, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_migrate(name, target.collection, split.key, forward.timeout = NULL, async = NULL, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_overseerstatus(raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_rebalanceleaders(name, maxAtOnce = NULL, maxWaitSeconds = NULL, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_reload(name, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_removerole(role = "overseer", node, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_requeststatus(requestid, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_splitshard(name, shard, ranges = NULL, split.key = NULL, async = NULL, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>core_status(name = NULL, indexInfo = TRUE, raw = FALSE, callopts=list())</code>
</p>
</li>
<li> <p><code>core_exists(name, callopts = list())</code>
</p>
</li>
<li> <p><code>core_create(name, instanceDir = NULL, config = NULL, schema = NULL, dataDir = NULL, configSet = NULL, collection = NULL, shard = NULL, async=NULL, raw = FALSE, callopts=list(), ...)</code>
</p>
</li>
<li> <p><code>core_unload(name, deleteIndex = FALSE, deleteDataDir = FALSE, deleteInstanceDir = FALSE, async = NULL, raw = FALSE, callopts = list())</code>
</p>
</li>
<li> <p><code>core_rename(name, other, async = NULL, raw = FALSE, callopts=list())</code>
</p>
</li>
<li> <p><code>core_reload(name, raw = FALSE, callopts=list())</code>
</p>
</li>
<li> <p><code>core_swap(name, other, async = NULL, raw = FALSE, callopts=list())</code>
</p>
</li>
<li> <p><code>core_mergeindexes(name, indexDir = NULL, srcCore = NULL, async = NULL, raw = FALSE, callopts = list())</code>
</p>
</li>
<li> <p><code>core_requeststatus(requestid, raw = FALSE, callopts = list())</code>
</p>
</li>
<li> <p><code>core_split(name, path = NULL, targetCore = NULL, ranges = NULL, split.key = NULL, async = NULL, raw = FALSE, callopts=list())</code>
</p>
</li>
<li> <p><code>search(name = NULL, params = NULL, body = NULL, callopts = list(), raw = FALSE,  parsetype = 'df', concat = ',', optimizeMaxRows = TRUE, minOptimizedRows = 50000L, progress = NULL, ...)</code>
</p>
</li>
<li> <p><code>facet(name = NULL, params = NULL, body = NULL, callopts = list(), raw = FALSE,  parsetype = 'df', concat = ',', progress = NULL, ...)</code>
</p>
</li>
<li> <p><code>stats(name = NULL, params = list(q = '*:*', stats.field = NULL, stats.facet = NULL), body = NULL, callopts=list(), raw = FALSE, parsetype = 'df', progress = NULL, ...)</code>
</p>
</li>
<li> <p><code>highlight(name = NULL, params = NULL, body = NULL, callopts=list(), raw = FALSE, parsetype = 'df', progress = NULL, ...)</code>
</p>
</li>
<li> <p><code>group(name = NULL, params = NULL, body = NULL, callopts=list(), raw=FALSE, parsetype='df', concat=',', progress = NULL, ...)</code>
</p>
</li>
<li> <p><code>mlt(name = NULL, params = NULL, body = NULL, callopts=list(), raw=FALSE, parsetype='df', concat=',', optimizeMaxRows = TRUE, minOptimizedRows = 50000L, progress = NULL, ...)</code>
</p>
</li>
<li> <p><code>all(name = NULL, params = NULL, body = NULL, callopts=list(), raw=FALSE, parsetype='df', concat=',', optimizeMaxRows = TRUE, minOptimizedRows = 50000L, progress = NULL, ...)</code>
</p>
</li>
<li> <p><code>json_request(name = NULL, body = NULL, callopts=list(),  progress = NULL)</code>
</p>
</li>
<li> <p><code>get(ids, name, fl = NULL, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>add(x, name, commit = TRUE, commit_within = NULL, overwrite = TRUE, boost = NULL, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>delete_by_id(ids, name, commit = TRUE, commit_within = NULL, overwrite = TRUE, boost = NULL, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>delete_by_query(query, name, commit = TRUE, commit_within = NULL, overwrite = TRUE, boost = NULL, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>update_json(files, name, commit = TRUE, optimize = FALSE, max_segments = 1, expunge_deletes = FALSE, wait_searcher = TRUE, soft_commit = FALSE, prepare_commit = NULL, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>update_xml(files, name, commit = TRUE, optimize = FALSE, max_segments = 1, expunge_deletes = FALSE, wait_searcher = TRUE, soft_commit = FALSE, prepare_commit = NULL, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>update_csv(files, name, separator = ',', header = TRUE, fieldnames = NULL, skip = NULL, skipLines = 0, trim = FALSE, encapsulator = NULL, escape = NULL, keepEmpty = FALSE, literal = NULL, map = NULL, split = NULL, rowid = NULL, rowidOffset = NULL, overwrite = NULL, commit = NULL, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>update_atomic_json(body, name, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>update_atomic_xml(body, name, wt = 'json', raw = FALSE, ...)</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre>
## Not run: 
# make a client
(cli &lt;- SolrClient$new())

# variables
cli$host
cli$port
cli$path
cli$scheme

# ping
## ping to make sure it's up
cli$ping("gettingstarted")

# version
## get Solr version information
cli$schema("gettingstarted")
cli$schema("gettingstarted", "fields")
cli$schema("gettingstarted", "name")
cli$schema("gettingstarted", "version")$version

# Search
cli$search("gettingstarted", params = list(q = "*:*"))
cli$search("gettingstarted", body = list(query = "*:*"))

# set a different host
SolrClient$new(host = 'stuff.com')

# set a different port
SolrClient$new(host = 3456)

# set a different http scheme
SolrClient$new(scheme = 'https')

# set a proxy
SolrClient$new(proxy = list(url = "187.62.207.130:3128"))

prox &lt;- list(url = "187.62.207.130:3128", user = "foo", pwd = "bar")
cli &lt;- SolrClient$new(proxy = prox)
cli$proxy

# A remote Solr instance to which you don't have admin access
(cli &lt;- SolrClient$new(host = "api.plos.org", path = "search", port = NULL))
cli$search(params = list(q = "memory"))

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>solrium</em> version 1.0.2 <a href="00Index.html">Index</a>]</div>
</body></html>
