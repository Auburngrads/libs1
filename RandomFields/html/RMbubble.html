<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Bubble model for arbitrary areas of scales</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for RMbubble {RandomFields}"><tr><td>RMbubble {RandomFields}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Bubble model for arbitrary areas of scales</h2>

<h3>Description</h3>

<p>A model that allows for arbitray areas of scale applied to an isotropic
model, i.e.
</p>
<p style="text-align: center;"><i>
    C(x,y) = &phi;(\|x -y \| / s) 
  </i></p>

<p>as long as <i>s_x = s_y = s</i>. Here,
<i>s_x</i> is the scaling at location <i>x</i>,
</p>
<p>The cross-correlations between areas of
different scales are given through a modified distance
<i>d</i>. Let <i>z_{s}</i> be a finite
subset of <i>R^d</i> depending on the scale <i>s</i>.
Let <i>w_u</i> be a weight for an auxiliary point <i>u\in z_{s}</i>
with <i>&sum;_{u \in z_s} w_u = 1</i>. 
Let <i>&tau;_x = s_x^{-2}</i>. Then
</p>
<p style="text-align: center;"><i>d^2(x, y) = \min\{&tau;(x), &tau;(y)\} \|x - y\|^2
    + &sum;_{&xi; \in_{span(&tau;(x), &tau;(y))}}
      &sum;_{u \in z_{&xi;^{-0.5}}} w_u
    \|x - u\|^2 &Delta; &xi;
  </i></p>

<p>Here, <i>span(&tau;(x), &tau;(y))</i> is the finite set of values
<i>s^{-2}</i> that are realized on the locations of interest
and <i>&Delta; &xi;</i> is the difference of two
realized and ordered values of the scaling <i>s</i>.
</p>


<h3>Usage</h3>

<pre>
RMbubble(phi, scaling, z, weight, minscale, barycentre,
         var, scale, Aniso, proj)</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>phi</code></td>
<td>
<p>isotropic submodel</p>
</td></tr>
<tr valign="top"><td><code>scaling</code></td>
<td>
<p>model that gives the non-stationary scaling <i>s_x</i></p>
</td></tr>
<tr valign="top"><td><code>z</code></td>
<td>

<p>matrix of the union of all <i>z_s</i>.
The number of rows equals the dimension of the field.
If not given, the locations with non-vanishing gradient are taken.
</p>
</td></tr>
<tr valign="top"><td><code>weight</code></td>
<td>
<p>vector of weights <i>w</i>
whose length equals the number of columns of <code>z</code>.
The points given by <code>z</code> might be weighted.
</p>
</td></tr>
<tr valign="top"><td><code>minscale</code></td>
<td>
<p>vector for partioning <i>z</i> into classes <i>z_s</i>.
Its length equals the number of columns of <code>z</code>. The vector
values must be descending. See details.
If not given then <i>z_s=</i><code>z</code> for all <i>s</i>.
Else see details.
</p>
</td></tr>
<tr valign="top"><td><code>barycentre</code></td>
<td>
<p>logical. If <code>FALSE</code> and <code>z</code> is not given,
the reference locations are those with non-vashing gradient. If
<code>TRUE</code> then, for each realized value of the scale, the
barycentre of the corresponding reference locations is used instead
of the reference locations themselves. This leads to higher
correlations, but also to highly non-stationary cross-correlation
between the areas of different scale.
</p>
<p>The argument has no effect when <code>z</code> is given.
</p>
<p>Default: <code>FALSE</code>.
</p>
</td></tr>
<tr valign="top"><td><code>var,scale,Aniso,proj</code></td>
<td>
<p>optional arguments; same meaning for any
<code><a href="RMmodel.html">RMmodel</a></code>. If not passed, the above
covariance function remains unmodified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>minscale</code> gives the minimal scale <i>s</i> value above which
the corresponding points <code>z</code> define the set <i>z_s</i>.
The validity of the set <i>z_s</i> ends with the next lower value
given.
</p>
<p>Let <code>minscale = (10, 10, 10, 7, 7, 7, 0.5)</code>. Then for some
<i>d</i>-dimensional vectors <i>z_1,&hellip;, z_7</i> we have
</p>
<p style="text-align: center;"><i>z_s = \{ z_1, z_2, z_3 \}, s &ge; 10</i></p>

<p style="text-align: center;"><i>z_s = \{ z_4, z_5, z_5 \},  7 &ge; s &lt; 10</i></p>

<p style="text-align: center;"><i>z_s = \{ z_7 \}, s &ge; 0.5</i></p>

<p>Note that, in this case, all realized scaling values must be
<i>&ge; 0.5</i>. Note further, that the weights for the subset must
sum up to one, i.e.
</p>
<p style="text-align: center;"><i>w_1+w_2 +w_3=w_4 + w_5 + w_6 = w_7 = 1.</i></p>



<h3>Value</h3>

<p><code><a href="RMbubble.html">RMbubble</a></code> returns an object of class <code><a href="RMmodel-class.html">RMmodel</a></code>.
</p>


<h3>Note</h3>

<p>This model is defined only for grids.</p>


<h3>Author(s)</h3>

<p>Martin Schlather, <a href="mailto:schlather@math.uni-mannheim.de">schlather@math.uni-mannheim.de</a>, <a href="http://ms.math.uni-mannheim.de">http://ms.math.uni-mannheim.de</a></p>


<h3>References</h3>


<ul>
<li><p> Bonat, W.H. , Ribeiro, P. Jr. and Schlather, M. (2019)
Modelling non-stationarity in scale. In preparation.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="RMSadvanced.html">RMSadvanced</a></code>,
<code><a href="RMblend.html">RMblend</a></code>,
<code><a href="RMscale.html">RMscale</a></code>
</p>


<h3>Examples</h3>

<pre>
RFoptions(seed=0) ## *ANY* simulation will have the random seed 0; set
##                   RFoptions(seed=NA) to make them all random again

x &lt;- seq(0,1, if (interactive()) 0.02 else 0.5)
d &lt;- sqrt(rowSums(as.matrix(expand.grid(x-0.5, x-0.5))^2))
d &lt;- matrix(d &lt; 0.25, nc=length(x))
image(d)

scale &lt;- RMcovariate(data=as.double(d) * 2 + 0.5, raw=TRUE)

## two models:
## the frist uses the standard approach for determining the
##           reference point z, which is based on gradients
## the second takes the centre of the ball
model1 &lt;- RMbubble(RMexp(), scaling=scale)
model2 &lt;- RMbubble(RMexp(), scaling=scale, z=c(0.5, 0.5))
model3 &lt;- RMbubble(RMexp(), scaling=scale, barycentre=TRUE) # approx. of model2

## model2 has slightly higher correlations than model1:
C1 &lt;- RFcovmatrix(model1, x, x)
C2 &lt;- RFcovmatrix(model2, x, x)
C3 &lt;- RFcovmatrix(model3, x, x) 
print(range(C2 - C1))
dev.new(); hist(C2 - C1)
print(range(C3 - C2)) # only small differences to C2
print(mean(C3 - C2))
dev.new(); hist(C3 - C2)

plot(z1 &lt;- RFsimulate(model1, x, x))
plot(z2 &lt;- RFsimulate(model2, x, x))
plot(z3 &lt;- RFsimulate(model3, x, x)) # only tiny differences to z2


## in the following we compare the standard bubble model with
## the models RMblend, RMscale and RMS (so, model2 above
## performs even better)
biwm &lt;- RMbiwm(nudiag=c(0.5, 0.5), nured=1, rhored=1, cdiag=c(1, 1), 
                s=c(0.5, 2.5, 0.5))
blend &lt;- RMblend(multi=biwm, blend=RMcovariate(data = as.double(d), raw=TRUE))
plot(zblend &lt;- RFsimulate(blend, x, x)) ## takes a while ...
Cblend &lt;- RFcovmatrix(blend, x, x)

Mscale &lt;- RMscale(RMexp(), scaling = scale, penalty=RMid() / 2)
plot(zscale &lt;- RFsimulate(Mscale, x, x))
Cscale &lt;- RFcovmatrix(Mscale, x, x)

Mscale2 &lt;- RMscale(RMexp(), scaling = scale, penalty=RMid() / 20000)
plot(zscale2 &lt;- RFsimulate(Mscale2, x, x))
Cscale2 &lt;- RFcovmatrix(Mscale2, x, x)

S &lt;- RMexp(scale = scale)
plot(zS &lt;- RFsimulate(S, x, x))
CS &lt;- RFcovmatrix(S, x, x)

print(range(C1 - CS))
print(range(C1 - Cscale))
print(range(C1 - Cscale2))
print(range(C1 - Cblend))
dev.new(); hist(C1-CS)     ## C1 is better
dev.new(); hist(C1-Cscale) ## C1 is better
dev.new(); hist(C1-Cscale2) ## both are equally good. Maybe C1 slightly better
dev.new(); hist(C1-Cblend) ## C1 is better




</pre>

<hr /><div style="text-align: center;">[Package <em>RandomFields</em> version 3.3.6 <a href="00Index.html">Index</a>]</div>
</body></html>
