<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Setting control arguments of 'RandomFields' - advanced...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for RFoptionsAdvanced {RandomFields}"><tr><td>RFoptionsAdvanced {RandomFields}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Setting control arguments of <span class="pkg">RandomFields</span> &ndash; advanced examples</h2>

<h3>Description</h3>

<p>Some more complex examples for the use of <code><a href="RFoptions.html">RFoptions</a></code>
are given.
</p>


<h3>Author(s)</h3>

<p>Martin Schlather, <a href="mailto:schlather@math.uni-mannheim.de">schlather@math.uni-mannheim.de</a>, <a href="http://ms.math.uni-mannheim.de">http://ms.math.uni-mannheim.de</a></p>


<h3>Examples</h3>

<pre>

 #############################################################
 ##                      EXAMPLE 1                          ##
 ## The following gives an example on the advantage of      ##
 ## dependent=TRUE for simulating with RPcirculant if, in a ##
 ## study, most of the time is spent with simulating the    ##
 ## Gaussian random fields. Here, the covariance at a pair  ##
 ## of points is estimated for n independent repetitions    ##
 ## and 2*n locally dependent repetitions.                  ##
 ## To get the precision, the procedure is repeated m times.##
 #############################################################

# In the example below, local.dependent speeds up the simulation
# by about factor 16 at the price of an increased variance of
# factor 1.5

RFoptions(seed=NA)
len &lt;- 10

x &lt;- seq(0, 1, len=len)
y &lt;- seq(0, 1, len=len)
grid.size &lt;- c(length(x), length(y))
meth &lt;- RPcirculant
model &lt;- RMexp(var=1.1, Aniso=matrix(nc=2, c(2,0.1,1.5,1)))

m &lt;- 5 
n &lt;- 100


# using local.dependent=FALSE (which is the default)
c1 &lt;- numeric(m)
time &lt;- system.time(
  for (i in 1:m) {
    cat("", i, "out of", m, "\n")
    z &lt;- RFsimulate(meth(model), x, y, n=n, pch="", 
                    dependent=FALSE, spConform=FALSE, trials=5, force=TRUE)
    c1[i] &lt;- cov(z[1, dim(z)[2], ], z[dim(z)[1], 1, ])
}) # many times slower than with local.dependent=TRUE below

true.cov &lt;- RFcov(model, t(y[c(1, length(y))]), t(x[c(length(x), 1)]))
print(time)
Print(true.cov, mean(c1), sd(c1), empty.lines=1)## true mean is zero

# using local.dependent=TRUE ...
c2 &lt;- numeric(m)
time &lt;- system.time(
  for (i in 1:m) {
    cat("", i)
    z &lt;- RFsimulate(meth(model), x, y, n=2 * n, pch="", 
                    dependent=TRUE, spConform=FALSE, trials=5, force=TRUE)
    c2[i] &lt;- cov(z[1, dim(z)[2], ], z[dim(z)[1], 1, ])
})

print(time)                                      ## 20 times faster
Print(true.cov, mean(c2), sd(c2), empty.lines=1) ## much better results

## the sd is smaller (using more locally dependent realisations)
## but it is (much) faster! Note that for n=n2 instead of n=2 * n, 
## the value of sd(c2) would be larger due to the local dependencies 
## in the realisations.




 #############################################################
 ##                      EXAMPLE 2                          ##
 ## This example shows that the same realisation can be     ##
 ## obtained on different grid geometries (or point         ##
 ## configurations, i.e. grid, non-grid) using TBM          ##
 #############################################################

RFoptions(seed=0)
step &lt;- 1
x1 &lt;- seq(-150,150,step)
y1 &lt;- seq(-15, 15, step)
x2 &lt;- seq(-50, 50, step)
model &lt;- RPtbm(RMexp(scale=10))


RFoptions(storing=TRUE)
mar &lt;- c(2.2, 2.2, 0.1, 0.1)
points &lt;- 700

###### simulation of a random field on long thin stripe
z1 &lt;- RFsimulate(model, x1, y1, center=0, seed=0,
                 points=points, storing=TRUE, spConform=FALSE)
ScreenDevice(height=1.55, width=12)
par(mar=mar)
image(x1, y1, z1, col=rainbow(100))
polygon(range(x2)[c(1,2,2,1)], range(y1)[c(1,1,2,2)],
        border="red", lwd=3)


###### definition of a random field on a square of shorter diagonal
z2 &lt;- RFsimulate(model, x2, x2, register=1, seed=0,
                 center=0, points=points, spConform=FALSE)
ScreenDevice(height=4.3, width=4.3)
par(mar=mar)
image(x2, x2, z2, zlim=range(z1), col=rainbow(100))
polygon(range(x2)[c(1,2,2,1)], range(y1)[c(1,1,2,2)],
        border="red", lwd=3)
tbm.points &lt;- RFgetModelInfo(level=3)$loc$totpts
Print(tbm.points, empty.lines=0) # number of points on the line


</pre>

<hr /><div style="text-align: center;">[Package <em>RandomFields</em> version 3.3.6 <a href="00Index.html">Index</a>]</div>
</body></html>
