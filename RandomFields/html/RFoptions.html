<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Setting control arguments</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for RFoptions {RandomFields}"><tr><td>RFoptions {RandomFields}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Setting control arguments</h2>

<h3>Description</h3>

<p><code><a href="RFoptions.html">RFoptions</a></code> sets and returns control arguments for the analysis
and the simulation of random fields. It expands the functionality of
<a href="../../RandomFieldsUtils/html/RFoptions.html">RFoptions</a>.
</p>


<h3>Usage</h3>

<p>RFoptions(...)
</p>


<h3>Arguments</h3>

  
<dl>
<dt>...</dt><dd><p>arguments in <code>tag = value</code> form, or a list of tagged
values.</p>
</dd>
</dl>







<h3>Details</h3>

<p>The subsections below comment on<br />
<b>0. <code>basic</code>: See <a href="../../RandomFieldsUtils/html/RFoptions.html">RFoptions</a></b><br />
<b>1. <code>general</code>: General options</b><br />
<b>2. <code>br</code>: Options for Brown-Resnick
Fields</b><br />
<b>3. <code>circulant</code>: Options for circulant embedding methods
<code><a href="RPcirculant.html">RPcirculant</a></code></b><br />
<b>4. <code>coords</code>: Options for coordinates and units, see
<a href="CoordinateSystems.html">coordinate systems</a></b><br />
<b>5. <code>direct</code>: Options for simulating by simple matrix decomposition</b><br />
<b>6. <code>distr</code>: Options for distributions, in particular <code><a href="RRrectangular.html">RRrectangular</a></code></b><br />
<b>7. <code>empvario</code>: Options for calculating the empirical variogram</b><br />
<b>8. <code>fit</code>: Options for <code><a href="RFfit.html">RFfit</a></code>,
<code><a href="RFratiotest.html">RFratiotest</a></code>, and <code><a href="RFcrossvalidate.html">RFcrossvalidate</a></code></b><br />
<b>9. <code>gauss</code>: Options for simulating Gaussian random fields</b><br />
<b>10. <code>graphics</code>: Options for graphical output</b><br />
<b>11. <code>gui</code>: Options for <code><a href="RFgui.html">RFgui</a></code></b><br />
<b>12. <code>hyper</code>: Options for simulating hyperplane tessellations</b><br />
<b>13. <code>krige</code>: Options for Kriging</b><br />
<b>14. <code>maxstable</code>: Options for simulating max-stable random fields</b><br />
<b>15. <code>mpp</code>: Options for the random coins (shot noise) methods</b><br />
<b>16. <code>nugget</code>: Options for the nugget effect</b><br />
<b>17. <code>registers</code>: Register numbers</b><br />
<b>18. <code>sequ</code>: Options for the sequential method</b><br />
<b>19. <code>solve</code>: Options for solving linear systems</b><br />
<b>20. <code>special</code>: Options for some special methods</b><br />
<b>21. <code>spectral</code>: Options for the spectral (turning bands) method</b><br />
<b>22. <code>tbm</code>: Options for the turning bands method</b><br />
<b>23. <code>internal</code>: Internal</b><br /><br /><br />
</p>





<p><b>1. General options</b>
</p>


<dl>
<dt><code>allowdistanceZero</code></dt><dd><p>boolean. Only used in
<code><a href="RFinterpolate.html">RFinterpolate</a></code> and in <code><a href="RFfit.html">RFfit</a></code>.
If true, then
multiple observations or identical locations
are allowed within a single data set.
In this case, the coordinates are slightly scattered, so that
the points have some tiny distances.
</p>
<p>Default: <code>FALSE</code>. 
</p>
</dd>
<dt><code>cPrintlevel</code></dt><dd>
<p><code>cPrintlevel</code> is automatically set to <code>printlevel</code>
when <code>printlevel</code> is changed.
Standard users will never use a value higher than 3.
</p>
<p>0 : no messages<br />
1 : messages and warnings when the user's input looks odd<br />
2 : messages (and internal errors) documenting the choice of the
simulation method<br />
3 : further user relevant informations<br />
4 : information on recursive function calls<br />
5 : function flow information of central functions <br />
6 : errors that are internally treated<br />
7 : details on building up the covariance structure<br />
8 : details on taking the square root of the covariance matrix<br />
9 : details on intermediate calculations<br />
10 : further details on intermediate calculations<br />
</p>
<p>Note that <code>printlevel</code> works
on the R level whereas <code>cPrintlevel</code> works on the C level.
</p>
<p>Default: 1 <br /> 
</p>
</dd>
<dt><code>detailed_output</code></dt><dd><p>logical.
if <code>TRUE</code> some function, e.g. <code><a href="RFcrossvalidate.html">RFcrossvalidate</a></code>
will return additional information.
</p>
</dd>
<dt><code>every</code></dt><dd><p>integer.
if greater than zero, then every <code>every</code>th iteration is
printed if simulated by TBM or random coin method. The value zero
means that nothing is printed.
</p>
<p>Default: <code>0</code> 
</p>
</dd>
<dt><code>exactness</code></dt><dd><p>logical or NA. Currently only used when simulating
Gaussian random fields.
</p>

<ul>
<li> <p><code>TRUE</code>: <code><a href="RPcoin.html">RPcoins</a></code>,
<code><a href="RPhyperplane.html">RPhyperplane</a></code>, <code><a href="RPsequential.html">RPsequential</a></code>,
<code><a href="RPspectral.html">RPspectral</a></code> and <code><a href="RPtbm.html">RPtbm</a></code> and
<em>approximative</em> circulant embedding  are excluded.
If the circulant embedding method is considered as badly
behaved, then the matrix decomposition methods are preferred.
</p>
</li>
<li> <p><code>FALSE</code>: all the methods are allowed.
If the circulant embedding method is
considered as badly behaved or the number of points to be
simulated is large, the turning bands methods are
rather preferred.
</p>
</li>
<li> <p><code>NA</code>: Similar to <code>FALSE</code>, but
some inexact algorithms get less preference.
</p>
</li></ul>

<p>Default: <code>NA</code> .
</p>
</dd>
<dt><code>expected_number_simu</code></dt><dd><p>positive integer which is usally set
internally as the value of the argument <code>n</code> in
<code><a href="RFsimulate.html">RFsimulate</a></code>. The argument <code>expected_number_simu</code>
should be set only by an advanced users and only if 
<code><a href="RFsimulate.html">RFsimulate</a></code> will be called with argument <code>n</code> alone.
</p>
</dd>
<dt><code>gridtolerance</code></dt><dd>
<p>used in <code><a href="RFsimulate.html">RFsimulate</a></code> to see if the coordinates build a
grid for x, y, z, T-values. This argument is also used
in case of conditional
simulation where the data locations might ly on
a grid.
</p>
<p>Default: <code>1e-6</code>
</p>
</dd>
<dt>asList</dt><dd><p>logical. Lists of arguments are treated slightly
different from non-lists. If <code>asList=FALSE</code> they are treated the
same way as non-lists. This options being set to <code>FALSE</code> after
calling <code>RFoptions</code> it should be set as first element of a list.
</p>
<p>Default: <code>TRUE</code>
</p>
</dd>
<dt><code>modus_operandi</code></dt><dd><p>character. One of the values
<code>"careless"</code>, <code>"sloppy"</code>, <code>"easygoing"</code>,
<code>"normal"</code>, <code>"precise"</code>, <code>"pedantic"</code>,
<code>"neurotic"</code> .
<b>This argument is in an experimental stage and its definition
and effects will change very likely in near future.</b>
This argument sets a lot of argument at once related to estimation
and simulation. <code>"careless"</code> prefers rather fast algorithms,
but the results
might be very rough approximations. By way of contrast,
<code>"neurotic"</code> will try very
hard to return exact result at the cost of hugh computing times.
</p>
<p>Default: <code>"normal"</code>
</p>
</dd>
<dt><code>na_rm_lines</code></dt><dd>
<p>logical. If <code>TRUE</code> then a line of the data that contains a
<code>NA</code> value is deleted. Otherwise it is tried to deal with the
<code>NA</code> value at higher costs of computing time. (Only used for
kriging &ndash; estimation can fully deal with <code>NA</code>s.)
</p>
<p>Default: <code>FALSE</code>.
</p>
</dd>
<dt><code>output</code></dt><dd><p>character.
one of the values <code>"sp"</code> (if and only if
<code>spConform=TRUE</code>), 
<code>"RandomFields"</code> (if and only if <code>spConform=FALSE</code>),
<code>"geoR"</code>.
</p>
<p>The output mode <code>geoR</code> currently adds some attributes such as
the call of the function.
</p>
<p>NOTE: <code>output</code> is in an experimental stage, whose effects might
change in future. Currently, <code>output</code> changes the values of
<code>reportcoord</code>, <code>returncall</code> and <code>spConform</code>.
</p>
</dd>
<dt><code>pch</code></dt><dd><p>character.
<code><a href="RFfit.html">RFfit</a></code>: shown before evaluating any method;
if <code>pch!=""</code> then one or two
additional steps in the MLE methods are
marked by &ldquo;+&rdquo; and &ldquo;#&rdquo;.
</p>
<p>Simulation: 
</p>
<p>The character is printed after each
performed simulation if more than one simulation is performed at
once. If <code>pch='!'</code> then an absolute
counter is shown instead of the character.
If <code>pch='%'</code> then a
counter of percentages is shown instead of the character.
Note that also &lsquo;<i>^</i>H&rsquo;s are printed in
the last two cases, 
which may have undesirable interactions with some few other R
functions, e.g. <code><a href="../../utils/html/Sweave.html">Sweave</a></code>.
</p>
<p>Default: <code>'*'</code>. 
</p>
</dd>
<dt><code>practicalrange</code></dt><dd><p>logical or integer.
If not <code>FALSE</code> the range of primitive
covariance functions is
adjusted so that cov(1) is zero for models with finite range.
(Operators are too complex to be adjusted; for anisotropic
covariance the practical range is not well defined.)
</p>
<p>The value of cov(1) is about 0.05 (for <code>scale=1</code>)
for models without range. See <code><a href="RMmodel.html">RMmodel</a></code> or type
<br />
<code><a href="RFgetModelNames.html">RFgetModelNames</a>(type="positive definite",
      domain="single variable", isotropy="isotropic", operator=FALSE, vdim=1)</code>
<br />
for the list of primitive models.
</p>

<ul>
<li> <p><code>FALSE</code> : the practical range ajustment is not used.
</p>
</li>
<li> <p><code>TRUE</code> : <code>practicalrange</code> is applicable only if
the value is known exactly, or, at least, can be approximated by
a closed formula.
</p>
</li>
<li> <p><code>2</code> : if the practical range is not known exactly it
is approximated numerically.	
</p>
</li></ul>

<p>Default: <code>FALSE</code> .
</p>
</dd>
<dt><code>printlevel</code></dt><dd><p>If <code>printlevel</code><i>&lt;=0</i>
there is not any output on the screen. The
higher the number the more tracing information is given. 
Standard users will never use a value higher than 3.
</p>
<p>0 : no messages<br />
1 : important (error) messages and warnings<br />
2 : less important messages<br />
3 : details, but still for the user<br />
4 : recursive call tracing (only used within <code><a href="RFfit.html">RFfit</a></code>)<br />
5 : function flow information of large functions<br />
6 : errors that are internally treated<br />
7 : details on intermediate calculations<br />
8 : further details on intermediate calculations<br />
</p>
<p>Default: 1 
</p>
</dd>
<dt>reportcoord</dt><dd><p>character.
Current values are <code>"always"</code>, <code>"important"</code>,
<code>"warn"</code>, <code>"never"</code>,
</p>
<p>Both <code>"warn"</code> and <code>"important"</code> have any effect only
if the coordinate system is changed internally. In this case
<code>"warn"</code> yields a displayed warning message whereas
<code>"important"</code> adds an attribute to the result as in the
case <code>"always"</code>.
</p>
<p>If <code>"always"</code> or <code>"important"</code>
the reports are added as attribute to the results.
Note that in this case the class of the result may change
(e.g. from <code>"numeric"</code> to <code>"atomic"</code>).
</p>
<p>Default: <code>"warn"</code>
</p>
</dd>
<dt>returncall</dt><dd><p>logical. If <code>TRUE</code>
then the call is returned as an attribute
</p>
<p>Default: <code>TRUE</code>
</p>
</dd>
<dt>seed</dt><dd><p>integer. If <code>NULL</code> or <code>NA</code>
<code><a href="../../base/html/Random.html">set.seed</a></code> is <b>not</b> called.
Otherwise, <code><a href="../../base/html/set.seed.html">set.seed</a>(seed)</code> is set
before simulations are performed, e.g. by
<code><a href="RFsimulate.html">RFsimulate</a></code> or <code><a href="RFdistr.html">RFdistr</a></code>.
</p>
<p>If the argument is set locally, i.e., within a function,
it has the usual local effect. If it is set globally, i.e. by
<code>RFoptions</code> the <code>seed</code> is fixed
for <b>all subsequent</b> calls.
</p>
<p>If the number of simulations <code>n</code> is greater than one
and if <code>RFoptions(seed=seed)</code> is set, the <i>i</i>th
simulation is started with the seed &lsquo;<code>seed</code><i>+i-1</i>&rsquo;.











</p>
<p>Note also that <code><a href="RFratiotest.html">RFratiotest</a></code> has its own argument
<code>seed</code> with a slightly different meaning.
</p>
</dd>
<dt>seed_incr, seed_sub_incr</dt><dd><p> (does not work yet)
This argument is important iff <code>RFsimulate</code> is used within
a function from package <span class="pkg">parallel</span>.
The value of <code>seed_incr</code> should be set only locally, i.e. not
by <code>RFoptions()</code>.
</p>
<p>If <code>seed_incr != 0</code> (or the number of simulations <code>n</code> is
greater than 1) and <code>!is.na(seed)</code>
then the seed for each simulation is calculated as
</p>
<p><code>seed</code> <i>+ (k-1) *</i> <code>seed_sub_incr</code>  <i>+</i> <code>seed_incr</code> <i>* n</i>
</p>
<p>where <i>k</i> runs from 1 to <code>n</code>.
</p>
<p>Default: 0
</p>
</dd>
<dt><code>set</code></dt><dd><p>integer.
Certain models (e.g. <code><a href="RMfix.html">RMfixcov</a></code> and
<code><a href="RMcovariate.html">RMcovariate</a></code>) 
allow for lists as arguments.
<code>set</code> selects a certain list element.
If necessary the list is recycled.
</p>
</dd>
<dt><code>spConform</code></dt><dd><p>logical.
<code>spConform=TRUE</code> might be used by
a standard user as this allows the comfortable use of <code>plot</code>,
for instance, while <code>spConform=FALSE</code> is <b>much</b> faster and
and consumes <b>much less memory</b>, hence might
be used by programmers or advanced users.
</p>
<p>Details: if <code>spConform=TRUE</code> then <code><a href="RFsimulate.html">RFsimulate</a></code> and
many other functions 
return an <code>sp</code>-object (which is an S4 object). Otherwise, matrices
or lists are 
returned as defined in RandomFields 2.0, see the manuals for the
specific functions. Frequently, the latter have now a class attribute
to make the output nicer.
</p>
<p>Note: for large data sets (to be generated),
<code>spConform=TRUE</code> should <b>not</b> be used.
</p>
<p>See also <code>output</code>.
</p>
<p>Default: <code>TRUE</code> 
</p>
</dd>
<dt><code>skipchecks</code></dt><dd><p>logical.
If <code>TRUE</code>, several checks whether the given parameter values
and the dimension are within the allowed range is skipped.
Do not change the value of this variable except you really
know what you do.
</p>
<p>Default: <code>FALSE</code> $ 
</p>
</dd>
<dt><code>storing</code></dt><dd><p>Logical.
If <code>FALSE</code> then the intermediate results are
destroyed after the simulation of the random field(s)
or if an error had occured.
If <code>storing=TRUE</code>, then
additional simulations can be performed by calling
<code><a href="RFsimulate.html">RFsimulate</a></code> with at most the argument <code>n</code>.
This call can then be much faster, but the a rather large
amount of memory could be kept.
</p>
<p>When <code>storing</code> turned from <code>TRUE</code> to <code>FALSE</code> by
global call then all registers are deleted.
Advanced:
With <code><a href="RFoptions.html">RFoptions</a>(storing=list(FALSE, register,
      model_register))</code>
single registers can be deleted.
</p>
<p>Default: <code>FALSE</code> 
</p>
</dd>
<dt><code>Ttriple</code></dt><dd><p>Logical or <code>NA</code>.
If <code>TRUE</code>, then triple for the time argument <code>T</code> is
expected, containing start, step (by), length.
If <code>FALSE</code> a sequence on a grid is expected.
If <code>NA</code> then the decision is automatic, but will lead to an
error if ambiguous.
</p>
</dd>
<dt><code>vdim_close_together</code></dt><dd><p>logical. Used especially in functions that
create covariance matrices. If the model is multivariate, then two
ways of ordering the matrix exist. To consider first all variables at
a certain location (<code>vdim_close_together=TRUE</code>) or to consider first
all locations keeping the variable fixed
(<code>vdim_close_together=FALSE</code>).
Note that several simulation methods rely on the value <code>FALSE</code>,
so that these methods will not work anymore if
<code>vdim_close_together=FALSE</code>. 
</p>
<p>Default: <code>FALSE</code>.
</p>
</dd>
</dl>


<p><b>2. Options for Brown-Resnick Fields</b>
</p>

<dl>
<dt><code>deltaAM</code></dt><dd> 
<p>integer; only used for simulation of BR processes via <code>RPbrmixed</code>
with <code>optim_mixed=2</code>. In this case, <code>deltaAM</code> is the number 
of additionally simulated Gaussian processes used for an update of
<code><a href="BRmethods.html">areamat</a></code> in the optimization pricedure.
</p>
<p>Default: <code>300</code>
</p>
</dd>
<dt><code>maxtrendmem</code></dt><dd>
<p>integer; the maximal number of real valued variables used for
intermediate storage:
</p>

<ul>
<li>
<p>RPbrshifted: trends for shifted locations that may
be stored at the same time when simulating BR processes.
</p>
</li>
<li>
<p>RPbrnormed: Let <i>n</i> be the number of locations.
Then a <i>n\times n</i> (covariance) matrix has to be evaluated
at random columns. 
</p>
</li></ul>

<p>if <code>maxtrendmem</code> is large (and <i>n</i> small, <i>n&le; 10^4</i>),
multiple evaluations can be avoided. 
</p>
<p>Default: <code>1e7</code> .
</p>
</dd>
<dt><code>meshsize</code></dt><dd>
<p>positive; width of the grid on which the shape functions in the M3
representation of BR processes are simulated; only used for
simulation of BR processes via <code>RPbrmixed</code>.
</p>
<p>Default:  <code>0.1</code> .
</p>
</dd>
<dt><code>optim_mixed</code></dt><dd><p><code>0, 1, 2</code>; only used for simulation of BR
processes via <code>RPbrmixed</code>.<br />
If <code>optim_mixed=0</code>, the arguments
<code><a href="BRmethods.html">lambda</a></code> and 
<code><a href="BRmethods.html">areamat</a></code> of <code><a href="BRmethods.html">RPbrmixed</a></code>
are used for the simulation.<br />
If <code>optim_mixed=1</code>, <code><a href="BRmethods.html">lambda</a></code> is estimated for
<code><a href="BRmethods.html">areamat=1</a></code>.<br />
If <code>optim_mixed=2</code>, <code><a href="BRmethods.html">areamat</a></code> is optimized and
<code><a href="BRmethods.html">lambda</a></code> is estimated.
</p>
<p>Default: <code>1</code> .
</p>
</dd>
<dt><code>optim_mixed_tol</code></dt><dd>
<p>value in <i>[0,1]</i>; only used for simulation of BR processes via
<code>RPbrmixed</code> with <code>optim_mixed=2</code>. In this case,
<code><a href="BRmethods.html">areamat</a></code> is optimized under the constraint that the
probability of drawing the shape function incorrectly is bounded by
<code>optim_mixed_tol</code> (cf. Oesting et al., 2012).
</p>
<p>Default: <code>0.01</code> .
</p>
</dd>
<dt><code>variobound</code></dt><dd>
<p>positive; the shape functions in the mixed moving maxima
representation are cut off where the variogram belonging
to <code>phi</code> exceeds <code>variobound</code>.
</p>
<p>Default: <code>8.0</code> .
</p>
</dd>
<dt><code>vertnumber</code></dt><dd>
<p>positive integer; for an efficient simulation of the shape functions
in the M3 representation of BR processes, the component <i>E</i> from
of the domain <i>[x_0, Inf] x E</i> of the
underlying Poisson point process is sub-dividedinto cubes
(cf. Oesting et al., 2012); <code>vertical</code>  is the number of
vertical breaks of <i>E</i>; only used for simulation of BR processes
via <code>RPbrmixed</code> with <code>optim_mixed=2</code>.
</p>
<p>Default: <code>7</code> .
</p>
</dd>
</dl>


<p><b>3. <code>circulant</code>: Options for circulant embedding methods, cf. <code><a href="RPcirculant.html">RPcirculant</a></code></b><br />
These options influence the standard circulant embedding
method, cutoff circulant embedding  intrinsic circulant embedding.
It can also influence <code><a href="RPtbm.html">RPtbm</a></code> if the line is simulated
with any circulant embedding method.
<br />
</p>

<dl>
<dt><code>approx_maxgrid</code></dt><dd><p>See <code><a href="RPcirculant.html">RPcirculant</a></code></p>
</dd>
<dt><code>approx_step</code></dt><dd><p>See <code><a href="RPcirculant.html">RPcirculant</a></code></p>
</dd>
<dt><code>dependent</code></dt><dd><p>See <code><a href="RPcirculant.html">RPcirculant</a></code></p>
</dd>
<dt><code>force</code></dt><dd><p>See <code><a href="RPcirculant.html">RPcirculant</a></code></p>
</dd>
<dt><code>maxGB</code></dt><dd><p>See <code><a href="RPcirculant.html">RPcirculant</a></code></p>
</dd>
<dt><code>maxmem</code></dt><dd><p>See <code><a href="RPcirculant.html">RPcirculant</a></code></p>
</dd>
<dt><code>mmin</code></dt><dd><p>See <code><a href="RPcirculant.html">RPcirculant</a></code></p>
</dd>
<dt><code>strategy</code></dt><dd><p>See <code><a href="RPcirculant.html">RPcirculant</a></code></p>
</dd>
<dt><code>tolIm</code></dt><dd><p>See <code><a href="RPcirculant.html">RPcirculant</a></code></p>
</dd>
<dt><code>tolRe</code></dt><dd><p>See <code><a href="RPcirculant.html">RPcirculant</a></code></p>
</dd>
<dt><code>trials</code></dt><dd><p>See <code><a href="RPcirculant.html">RPcirculant</a></code></p>
</dd>
<dt><code>useprimes</code></dt><dd><p>See <code><a href="RPcirculant.html">RPcirculant</a></code></p>
</dd>
</dl>


<p><b>4. <code>coords</code>: Options for coordinates and units</b>
</p>

<dl>
<dt><code>coord_system</code></dt><dd><p>character. See <a href="CoordinateSystems.html">coordinate systems</a>
</p>
</dd>
<dt><code>coordunits</code></dt><dd><p> See <a href="CoordinateSystems.html">coordinate systems</a>
</p>
</dd>
<dt><code>coordnames</code></dt><dd><p>See <a href="CoordinateSystems.html">coordinate systems</a>
</p>
</dd>
<dt><code>new_coord_system</code></dt><dd><p>See <a href="CoordinateSystems.html">coordinate systems</a>
</p>
</dd>
<dt><code>new_coordunits</code></dt><dd><p>See <a href="CoordinateSystems.html">coordinate systems</a>
</p>
</dd>
<dt><code>polar_coord</code> </dt><dd><p>See <a href="CoordinateSystems.html">coordinate systems</a>
</p>
</dd>
<dt><code>varnames</code></dt><dd><p>See <a href="CoordinateSystems.html">coordinate systems</a>
</p>
</dd>  
<dt><code>varunits</code></dt><dd><p>See <a href="CoordinateSystems.html">coordinate systems</a>
</p>
</dd>
<dt><code>xyz_notation</code></dt><dd><p>See <a href="CoordinateSystems.html">coordinate systems</a>
</p>
</dd>
<dt><code>zenit</code></dt><dd><p>See <a href="CoordinateSystems.html">coordinate systems</a>
</p>
</dd>
</dl>


<p><b>5. <code>direct</code>: Options for simulating by simple matrix decomposition</b>
</p>

<dl>
<dt><code>max_variab</code></dt><dd><p>Maximal size of the covariance matrix.
</p>
<p>Default: 12000
</p>
</dd>
</dl>


<p><b>6. <code>distr</code>: Options for distributions, in particular <code><a href="RRrectangular.html">RRrectangular</a></code></b>
</p>

<dl>
<dt><code>innermin</code></dt><dd>
<p>Default value to simulate from the
<code><a href="RRrectangular.html">RRrectangular</a></code> distribution.
The minimal length of the interval where the Taylor expansion shall
be valid.
</p>
<p>Default: <code>1e-20</code> .
</p>
</dd>
<dt><code>maxit</code></dt><dd>
<p>Default value to simulate from the
<code><a href="RRrectangular.html">RRrectangular</a></code> distribution.
</p>
<p>The number of iterative steps where the
the constant of the Taylor development is increased,
to find an upper bound for the given function.
</p>
<p>Default: <code>20</code> .
</p>
</dd>
<dt><code>maxsteps</code></dt><dd>
<p>Default value to simulate from the
<code><a href="RRrectangular.html">RRrectangular</a></code> distribution.
</p>
<p><code>maxsteps</code> is usually the number of steps in the middle part of
the approximation. From this value and the length between
the determined endpoints for  the approximation at the origin and in
the tail, the step length is calculated. If the step length is less
than <code>minsteplen</code> the number of steps is reduced.
</p>
<p>Default: <code>1000</code> .
</p>
</dd>
<dt><code>mcmc_n</code></dt><dd>
<p>In case of the use of MCMC it leaves out <i>n-1</i>
member of the Markov chain bevor the <i>n</i> member
is returned. See also maxsteps.
</p>
<p>Default: <code>15</code> .
</p>
</dd>
<dt><code>minsteplen</code></dt><dd>
<p>Default value to simulate from the
<code><a href="RRrectangular.html">RRrectangular</a></code> distribution.
The minimal step length
for the middle part of approximation, which is a step function,
</p>
<p>Default: <code>0</code> (i.e. not used as a criterion.)
</p>
</dd>
<dt><code>outermax</code></dt><dd>
<p>Default value to simulate from the
<code><a href="RRrectangular.html">RRrectangular</a></code> distribution.
The largest possible endpoint for the middle part that
approximates the function by a step function. See also <code>innermax</code>.
</p>
<p>Default: 20.
</p>
</dd>
<dt><code>parts</code></dt><dd>
<p>Default value to simulate from the
<code><a href="RRrectangular.html">RRrectangular</a></code> distribution.
</p>
<p><code>parts</code> determines the number of tests that are performed to
check whether a proposed power function is an upper bound for
the given function, at the origin and the tail.
</p>
<p>Default: <code>8</code> .
</p>
</dd>
<dt><code>repetitions</code></dt><dd>
<p>Minimal number of realisations to determine a quantity of the
distribution by MCMC. E.g. to determine the integral value <i>c</i>
in the paper of Oesting, Schlather, Zhou.
</p>
<p>Default: 1000.
</p>
</dd>
<dt><code>safety</code></dt><dd> 
<p>Default value to simulate from the
<code><a href="RRrectangular.html">RRrectangular</a></code> distribution.
</p>
<p>First, at the origin, the first power function of the Taylor
expansion is taken as potential upper function.
The constant of the power function are increased by factor
<i>1 + </i><code>safety</code> and the exponent of the function
similarly decreased. A number of test evaluations
is performed to check whether this modified function is indeed
a upper bound. If not, the considered interval at the origin
is reduced iteratively, the constants of the power function
further increased and the exponent decreased.
If <code>maxit</code> iteration have been performed without success,
the search for an upper bound fails.
The search at the origin also fails if the interval around
the origin has become less than <code>innermin</code>.
</p>
<p>Similar procedure is performed for the tail.
</p>
<p>Default: <code>0.08</code> .
</p>
</dd>
</dl>


<p><b>7. <code>empvario</code>: Options for calculating the empirical variogram</b>
</p>
 
<dl>
<dt><code>fft</code></dt><dd>
<p>Logical. Determines whether FFT should be used for data on a grid
Default: <code>TRUE</code>.
</p>
</dd>
<dt><code>phi0</code></dt><dd>
<p>numeric. In case of anisotropic fields directional cones are
considered. The argument <code>phi0</code> determines the starting angle.
</p>
<p>Default: <code>0</code>.
</p>
</dd>
<dt><code>pseudovariogram</code></dt><dd>
<p>logical. Only in the multivariate case. Whether the
pseudovariogram or the crossvariogram should be calculated.
</p>
<p>Default: <code>FALSE</code>.
</p>
</dd>
<dt><code>theta0</code></dt><dd>
<p>numeric. In case of anisotropic fields directional cones are
considered. The argument <code>theta0</code> determines one of the
boundaries, hence all boundaries for a given fixed number of cones.
The argument <code>theta0</code> determines the starting value of the
second anglue in polar coordinate representation in 3 dimensions.
</p>
<p>Default: <code>0</code>.
</p>
</dd>
<dt><code>tol0</code></dt><dd>
<p>numeric. Estimated values of the empirical variogram
below <code>tol0</code> times the grid step in the third dimension
are considered to be zero. Hence the respective values are set
to zero.
</p>
<p>Default: <code>1e-13</code>.
</p>
</dd>
</dl>


<p><b>8. <code>fit</code>: Options for <code><a href="RFfit.html">RFfit</a></code>,
<code><a href="RFratiotest.html">RFratiotest</a></code>, and <code><a href="RFcrossvalidate.html">RFcrossvalidate</a></code></b>
</p>

<dl>
<dt><code>algorithm</code></dt><dd>
<p>See <a href="RFfitOptimiser.html">RFfitOptimiser</a>.
</p>
<p>Default: <code>NULL</code>
</p>
</dd>
<dt><code>approximate_functioncalls</code></dt><dd>
<p>In case the parameter vector is too close to the given
bounds, the ML target function is evaluated on a grid
to get a new initial value for the ML estimation. 
The number of points of the grid is approximately
<code>approximate_functioncalls</code>.
</p>
<p>Default: <code>50</code>
</p>
</dd>
<dt><code>boxcox_lb</code></dt><dd>
<p>lower bound for the Box-Cox transformation
</p>
<p>Default: <code>-10</code>.
</p>
</dd>
<dt><code>boxcox_ub</code></dt><dd>
<p>upper bound for the Box-Cox transformation
</p>
<p>Default: <code>10</code>.
</p>
</dd>
<dt><code>bin_dist_factor</code></dt><dd>
<p>numeric. The empirical variogram is calculated up the distance
<code>bin_dist_factor</code> times (maximum distance among any pair of locations)
</p>
<p>Default: <code>0.5</code>.
</p>
</dd>
<dt><code>bins</code></dt><dd><p>vector of explicit boundaries for the bins or the
number of bins for the empirical variogram (used in the
LSQ target function, which is described at the beginning
of the Details).
Note that for anisotropic models, the value of <code>bins</code> might
be enlarged.
</p>
<p>Default: <code>20</code>.
</p>
</dd>
<dt><code>critical</code></dt><dd><p>logical or signed integer.
</p>
<p>If <code>critical=FALSE</code> and if the result of
any maximum likelihood method 
is on a borderline, then the optimisation is redone
in a modified way (which takes about double extra time)
</p>
<p>If <code>critical=TRUE</code> and if the result of
any maximum likelihood method
is on a borderline, then a kind of profile likelihood
optimization is done (which takes about 10 times extra time)
</p>
<p>If <code>critical&gt;=2</code> then a kind of profile likelihood
optimization is always done (which takes about <code>n_crit</code>
times extra time) for an automatically chosen selection
of the model parameters.
</p>
<p>If <code>critical&gt;=3</code> then a kind of profile likelihood
optimization is always done (which takes about <code>n_crit</code>
times extra time) for all the parameters.
</p>
<p>If <code>critical&lt;0</code> then none of the refined methods
are performed.
</p>
<p>Default: <code>TRUE</code>.
</p>
</dd>
<dt><code>cross_refit</code></dt><dd><p>logical. 
For each of the subset of the cross-validation method
the parameters have to be fitted to the given model.
If <code>cross_refit</code> is <code>TRUE</code>, this is done, but takes a huge
amount of time. If <code>FALSE</code>, the model is fitted only once to
the data and the value at
each point is predicted with the same model given
the values of the other points.
</p>
<p>Default: <code>FALSE</code>.
</p>
</dd>
<dt>estimate_variance</dt><dd>
<p>see <code><a href="RFloglikelihood.html">RFlikelihood</a></code>.
</p>
</dd>
<dt>factr, factr_recall</dt><dd>
<p>See the argument <code>control</code> in <a href="../../stats/html/optim.html">optim</a>.
<code>factr_recall</code> is used for intermediate calculations.
</p>
</dd>
<dt>likelihood</dt><dd><p>character &ndash; not programmed yet.
types of likelihood are <code>"auto"</code>, <code>"full"</code>,
<code>"composite"</code>, <code>"tesselation"</code>; 
</p>
<p>Default: <code>"auto"</code>    
</p>
</dd>
<dt><code>lowerbound_scale_factor</code></dt><dd>
<p>The lower bound for the scale is determined as
</p>
<p>(minimum distance between different pairs of points) /<br />
<code>lowerbound_scale_factor</code>.
</p>
<p>Default: <code>3</code>.
</p>
</dd>
<dt><code>lowerbound_scale_ls_factor</code></dt><dd><p> For the LSQ target
function a different lower bound 
for the scale is used. It is determined as
</p>
<p>(minimum distance between different pairs of points) / <br />
<code>lowerbound_scale_ls_factor</code>.
</p>
<p>Default: <code>5</code>.
</p>
</dd>
</dl>





<dl>
<dt><code>lowerbound_var_factor</code></dt><dd>
<p>The lower bound for the nugget and the variance is determined
as var(<code>data</code>) / <code>lowerbound_var_factor</code>.
If a standard model definition is given and
either the nugget or the variance is fixed,
the parameter to be estimated
must also be greater than <code>lowerbound_sill</code>.
</p>
<p>Default: <code>10000</code>.
</p>
</dd>
<dt><code>maxmixedvar</code></dt><dd><p>OBSOLETE.
upper bound for variance in a mixed model;
so, the covariance model for mixed model part might
be calibrated appropriately
</p>
</dd>
<dt><code>max_neighbours</code></dt><dd><p>integer.
Maximum number of locations (with depending values)
that are allowed.
</p>
<p>Default: <code>5000</code>.
</p>
</dd>
<dt><code>minbounddistance</code></dt><dd>
<p>If any value of the parameter vector
returned from the ML estimation
is closer than <code>minbounddistance</code>
to any of the bounds or if any value
has a relative distance smaller than
<code>minboundreldist</code>, then it is assumed that
the MLE algorithm has dropped into a local minimum,
and it will be continued with evaluating the
ML target function on a grid, cf. the beginning paragraphs
of the Details.
</p>
<p>Default: <code>0.001</code>.
</p>
</dd>
<dt><code>minboundreldist</code></dt><dd><p>relative distance to the bounds
below which a part of the algorithm is considered as
having failed. See <code>minbounddistance</code>.
</p>
<p>Default: <code>0.02</code>.
</p>
</dd>
<dt><code>min_diag</code></dt><dd>
<p>Minimal value of any estimated diagonal matrix element.    
</p>
<p>Default: <code>1e-7</code>.
</p>
</dd>
<dt><code>n_crit</code></dt><dd><p>integer.
The approximate profiles that are considered.
</p>
<p>Default: <code>10</code>.
</p>
</dd>
<dt><code>nphi</code></dt><dd><p>scalar or vector of 2 components.
If it is a vector then the first component gives the first angle
of the xy plane
and the second one gives the number of directions on the half circle.
If scalar then the first angle is assumed to be zero.
Note that a good estimation of the variogramm by LSQ with a
anisotropic model a large value for <code>ntheta</code> might be needed
(about 20).
</p>
<p>Default: <code>1</code>. 
</p>
</dd>
<dt><code>ntheta</code></dt><dd><p>scalar or vector of 2 components.
If it is a vector then the first component gives the first angle
in the third direction
and the second one gives the number of directions on the half circle.
If scalar then the first angle is assumed to be zero.
</p>
<p>Note that a good estimation of the variogramm by LSQ with a
anisotropic model a large value for <code>ntheta</code> might be needed
(about 20). 
</p>
<p>Default: <code>1</code>. 
</p>
</dd>
<dt><code>ntime</code></dt><dd><p>scalar or vector of 2 components.
if <code>ntimes</code> is a vector, then the first component are the
maximum time distance (in units of the grid length <code>T[3]</code>) and the
second component gives the step size (in units of the grid length
<code>T[3]</code>). If scalar then the step size is assumed to 1 (in units
of the grid length <code>T[3]</code>).
</p>
<p>Default: <code>20</code>. 
</p>
</dd>
<dt><code>only_users</code></dt><dd><p>boolean.
If true then only <code>users_guess</code> is used as a
starting point for the fitting algorithms
</p>
<p>Default: <code>FALSE</code>. 
</p>
</dd>
<dt><code>optimiser</code></dt><dd>
<p>See <a href="RFfitOptimiser.html">RFfitOptimiser</a>.
</p>
<p>Default: <code>"optim"</code>.
</p>
</dd>
</dl>































<dl>
<dt>pgtol, pgtol_recall</dt><dd>
<p>See the argument <code>control</code> in <a href="../../stats/html/optim.html">optim</a>.
<code>pgtol_recall</code> is used for intermediate calculations.
</p>
</dd>
<dt><code>refine_onborder</code></dt><dd><p>logical.
If <code>TRUE</code> and an estimated parameter of the model
is close to the boundary, a second search for the optimum
is started.
</p>
<p>Default: <code>TRUE</code>
</p>
</dd>
<dt><code>minmixedvar</code></dt><dd>
<p>lower bound for variance in a mixed model;
so, the covariance model for mixed model part might
be calibrated appropriately
</p>
<p>Default:  1/1000
</p>
</dd>
</dl>










<dl>
<dt><code>ratiotest_approx</code></dt><dd><p>logical.
if <code>TRUE</code> the approximative formula that twice the
difference of the likelihoods follow about a <i>&chi;^2</i>
distribution is used. The parameter of freedom equals
the number of parameters to be estimated for the covariance
function, including those for the covariates.
</p>
<p>Default: <code>TRUE</code>
</p>
</dd>
<dt><code>reoptimise</code></dt><dd><p>logical.
If <code>TRUE &amp;&amp; !only_users</code> then at a very last step,
the optimisation is redone with currently best parameters
and likelihood as scale parameter for <code><a href="../../stats/html/optim.html">optim</a></code>.
</p>
<p>Default: <code>TRUE</code>. 
</p>
</dd>
<dt><code>scale_max_relative_factor</code></dt><dd><p> If the initial scale
value for the ML estimation 
obtained by the LSQ target function is
less than
<i>(minimum distance
      between different pairs of points) / </i>
<code>scale_max_relative_factor</code>
</p>
<p>a warning is given that probably a nugget effect
is present. 
Note: if <code>scale_max_relative_factor</code> is greater
than <code>lowerbound_scale_ls_factor</code> then
no warning is given as
the scale has the lower bound <i>(minimum distance
      between different pairs of points) / </i>
<code>lowerbound_scale_ls_factor</code>.
</p>
<p>Default: <code>1000</code>
</p>
</dd>
<dt><code>scale_ratio</code></dt><dd>
<p><code><a href="RFfit.html">RFfit</a></code> uses <code>parscale</code> and <code>fnscale</code>
in the calls of <code><a href="../../stats/html/optim.html">optim</a></code>. As these arguments should
have the magnitude of the estimated values, <code><a href="RFfit.html">RFfit</a></code>
checks this by calculating the absolute log ratios.
If they are larger than <code>scale_ratio</code>,
<code>parscale</code> and <code>fnscale</code> are reset and the optimisation
is redone. 
</p>
<p>Default: <code>0.1</code>. 
</p>
</dd>
<dt><code>shortnamelength</code></dt><dd>
<p>The names of the variables in the returned table are
abbreviated by taking the first <code>shortnamelength</code>
letters.
</p>
<p>Default: <code>4</code>. 
</p>
</dd>
</dl>











<dl>
<dt><code>smalldataset</code></dt><dd>
<p>If the number of locations is considered as small, then some more data
are kept in the storage to accelerate the estimation algorithm.
</p>
<p>Default: <code>2000</code>.
</p>
</dd>
<dt><code>split</code></dt><dd><p>integer.
If the number of parameters to be numerically optimised is larger
than or equal to <code>split</code> then <code><a href="RFfit.html">RFfit</a></code> checks whether a
space-time covariance model or a multivariate covariance model
can be split into components, so that certain parameters
can be estimated separately.
</p>
<p>Default: <code>4</code>. 
</p>
</dd>
<dt><code>cliquesize</code></dt><dd><p>integer.
<code><a href="RFfit.html">RFfit</a></code> tries to split the data set
into parts of size splitn_neighbours[2] or less, but never more than 
<code>splitn_neighbours[3]</code> and never less than
splitn_neighbours[1].     
</p>
<p>Default: <code>c(200, 1000, 3000)</code>.
</p>
</dd>
<dt><code>splitfactor_neighbours</code></dt><dd>
<p>The total number of neighbouring boxes in each direction
<i>1 + 2\code{splitfactor}</i>, including the current box itself.
</p>
<p>Default: <code>2</code>.
</p>
</dd>
<dt><code>split_refined</code></dt><dd><p>logical.
If <code>TRUE</code> then also submodels are fitted if splitted.
This takes more time, but <code><a href="RFfit-class.html">anova</a></code> and
<code><a href="RFratiotest.html">RFratiotest</a></code>, for instance,
will give additional information.
</p>
<p>Default: <code>TRUE</code>.
</p>
</dd>
<dt><code>upperbound_scale_factor</code></dt><dd>
<p>The upper bound for the scale is determined
as
</p>
<p><code>upperbound_scale_factor</code> * (maximum distance
between all pairs of points).
</p>
<p>Default: <code>3</code>.
</p>
</dd>
<dt><code>upperbound_var_factor</code></dt><dd><p> The upper bound for the
variance and the nugget is determined 
as <code>upperbound_var_factor</code> * var(<code>data</code>)
</p>
<p>Default: <code>10</code>.
</p>
</dd>
<dt><code>use_naturalscaling</code></dt><dd>
<p>logical. Only used if model is given in standard (simple) way.
If <code>TRUE</code> then <em>internally</em>, rescaled
covariance functions will be used for which
cov(1)<i>~=</i>0.05.
<code>use_naturalscaling</code> has the advantage that <code>scale</code>
and the form parameters of the model get &lsquo;orthogonal&rsquo;,
but <code>use_naturalscaling</code> does not work for all models.
</p>
<p>Note that this argument does not influence
the output of <code><a href="RFfit.html">RFfit</a></code>: the parameter vector
returned by <code><a href="RFfit.html">RFfit</a></code> refers
<em>always</em> to the standard covariance model as given in
<code><a href="RMmodel.html">RMmodel</a></code>. (In contrast to <code>practicalrange</code>
in <code><a href="RFoptions.html">RFoptions</a></code>.)<br />
Advantages if <code>use_naturalscaling=TRUE</code>:
</p>

<ul>
<li> <p><code>scale</code> and the shape parameter of a parameterised
covariance model can be estimated better if they are estimated
simultaneously.
</p>
</li>
<li><p> The estimated bounds calculated by means of
<code>upperbound_scale_factor</code> and <code>lowerbound_scale_factor</code>,
etc. might be more realistic.
</p>
</li>
<li><p> in case of anisotropic models, the inverse of the elements
of the anisotropy matrix should be in the above bounds.
</p>
</li></ul>

<p>Disadvantages if <code>use_naturalscaling=TRUE</code>:
</p>

<ul>
<li><p> For some covariance models with additional parameters, the
rescaling factor has to be determined numerically.
Then, more time is needed to perform <code><a href="RFfit.html">RFfit</a></code>.
</p>
</li>
<li><p> note the <code>use_naturalscaling</code> only affects simple
models, no operators. Also functions that define a parameter of
the model are not changed.      
</p>
</li></ul>

<p>Default: <code>FALSE</code>.
</p>
</dd>
</dl>


<p><b>9. <code>gauss</code>: Options for simulating Gaussian random fields</b>
</p>

<dl>
<dt><code>approx_zero</code></dt><dd>
<p>Value below which a correlation is considered to be essentially zero.
This argument is used to determine the practical range of covariance
function with non-compact support.
</p>
<p>Default: <code>0.05</code>
</p>
</dd>
<dt><code>boxcox</code></dt><dd>
<p>real vector of one or two components.
If the first component is <code>Inf</code> then no transformation
is performed. Otherwise the BoxCox transformation is performed.
Note that Box Cox only works in a Gaussian framework.
Note further that either <code>boxcox</code> or <code>loggauss</code>
may be given.
</p>
<p>Default <code>c(Inf, 0)</code>
</p>
</dd>
<dt><code>direct_bestvar</code></dt><dd><p>integer.
When searching for an appropriate simuation method
the matrix decomposition method (<code>method="direct"</code>)
is preferred if the number of variables is less than or equal to 
<code>direct_bestvariables</code>.
</p>
<p>Default is <code>1200</code>.
</p>
</dd>
<dt><code>loggauss</code></dt><dd>
<p>logical. Whether a log-Gauss random fields should be returned.
See also <code>boxcox</code> for a generalisation.
</p>
</dd>
<dt><code>paired</code></dt><dd>
<p>(&ldquo;Antithetic pairs&rdquo;.)
Logical. If <code>TRUE</code> then the second half of the
simulations is logical. If <code>TRUE</code> then the second half of the
simulations is obtained by
only changing the signs of all the standard Gaussian random variables,
on which the first half of the 
simulations is based. Default is <code>FALSE</code>.
</p>
</dd>
<dt><code>stationary_only</code></dt><dd>
<p>See <code><a href="RPgauss.html">RPgauss</a></code>
</p>
</dd>
</dl>


<p><b>10. <code>graphics</code>: Options for graphical output</b>
</p>

<dl>
<dt><code>always_close_device</code></dt><dd><p>logical.
If <code>FALSE</code> the current device is kept as it is;
otherwise the current device is closed before the next
device is opened. If <code>NA</code> it closes the preceding device
if the opened device is pdf or jpeg.
</p>
<p>Default: <code>NA</code>.
</p>
</dd>
<dt><code>always_open_device</code></dt><dd><p>logical.
If <code>TRUE</code> a new graphical window is opened for every
<code><a href="../../graphics/html/plot.html">plot</a></code> if a standard graphical output is
used, trying to respect the aspect ratios for the plots.
The devices pdf and jpeg are always opened.
</p>
<p>If <code>NA</code> then the value is set
to <code><a href="../../base/html/interactive.html">interactive</a>()</code>. 
</p>
<p>Default: <code>TRUE</code>.
</p>
</dd>
<dt><code>close_screen</code></dt><dd><p>logical; only relevant if
<code>split_screen = TRUE</code> and <code>always_close_screen = FALSE</code>.
If <code>FALSE</code> the windows opened by
<code><a href="../../graphics/html/split.screen.html">split.screen</a></code> are left open.
</p>
<p>Default: <code>TRUE</code>.
</p>
</dd>
</dl>
<p><code>file</code>character; only relevant if
<code>split_screen = TRUE</code>.
argument <code>file</code> in <code><a href="../../grDevices/html/pdf.html">pdf</a></code>
If <code>""</code> then no internal naming is performed.
</p>
<p>Default: <code>""</code>.

</p>
<dl>
<dt><code>filenumber</code></dt><dd><p>integer; only relevant if
<code>split_screen = TRUE</code>. Starting number of the file if
<code>onefile=FALSE</code>. It is set to 0 whenever <code>file</code> is
changed and <code>onefile=FALSE</code>. 
</p>
<p>Default 0.
</p>
</dd>
<dt><code>grDefault</code></dt><dd>
<p>logical. If <code>FALSE</code> the graphic style up to Version 3.2
is used. Otherwise, the changes of th graphical style are reduced to
a minimum.
</p>
<p>Default: <code>FALSE</code> 
</p>
</dd>
<dt><code>grPrintlevel</code></dt><dd>
<p>integer values 0, 1, 2; only relevant when simulations are
plotted. The higher the more text is shown in the 
plot.
</p>
<p>Default: <code>1</code>.
</p>
</dd>
<dt><code>height</code></dt><dd><p>real number; only relevant if
a new device is opened, see <code>alwyas_open_screen</code>.
</p>

<ul>
<li> <p><code>height=NA</code> or <code>height</code> is not positive: no device
is opened.
</p>
</li>
<li> <p><code>width = NA</code>
If <code>height</code> is greater than zero then it gives the height
of a single figure in a plot created by <span class="pkg">RandomFields</span>;
See also <code>close_screen</code>.
</p>
<p>If plots with multiple figures are
shown, the height and width of the plot
will be increased by a factor up the
ones given by <code>increase_upto</code>.
</p>
<p>The width is calculated so that the aspect ratio is correct.
</p>
</li>
<li> <p><code>width</code> not <code>NA</code>
<code>height</code> and <code>width</code> give the size of the
whole window.
</p>
</li></ul>

<p>Default: <code>6</code>.
</p>
</dd>
<dt><code>increase_upto</code></dt><dd>
<p>See <code>height</code>.
</p>
<p>Default: <code>c(3,4)</code>.
</p>
</dd>
<dt><code>split_screen</code></dt><dd><p>logical.
If <code>TRUE</code> <code><a href="../../graphics/html/split.screen.html">split.screen</a></code>
is used to split the screen.
Otherwise <code>par(mfcol)</code>.
When using <code>split_screen</code> then the figures tend to be fancier.
</p>
<p>Default: <code>TRUE</code>.
</p>
</dd>
<dt><code>onefile</code></dt><dd><p>logical; only relevant if
<code>split_screen = TRUE</code>.
About the behaviour of argument <code>onefile</code> in
<code><a href="../../grDevices/html/pdf.html">pdf</a></code>
</p>
<p>Default: <code>FALSE</code>.
</p>
</dd>
<dt><code>width</code></dt><dd><p>real number or NA; only relevant if
<code>always_open_screen=TRUE</code>. See <code>height</code> for details.
</p>
<p>Default: <code>NA</code>.
</p>
</dd>
</dl>


<p><b>11. <code>gui</code>: Options for c<code><a href="RFgui.html">RFgui</a></code></b>
</p>

<dl>
<dt><code>alwaysSimulate</code></dt><dd>
<p>logical. If <code>TRUE</code> then a new random field is simulated
whenever a parameter is changed. Otherwise only the covariance
function or the variogram is re-plotted; simulations are performed
only when the correponding button is pressed.
</p>
<p>Default: <code>TRUE</code>.
</p>
</dd>
<dt><code>simu_method</code></dt><dd>
<p><code>"RPcirculant"</code>,
<code>"RPcutoff"</code>,
<code>"RPintrinsic"</code>,
<code>"RPtbm"</code>, 
<code>"RPspectral"</code>,
<code>"RPdirect"</code>,
<code>"RPsequential"</code>,
<code>"RPaverage"</code>,
<code>"RPnugget"</code>,
<code>"RPcoins"</code>,
<code>"RPhyperplane"</code>,
<code>"RPspecific"</code>,
<code>"any method"</code>.
</p>
<p>Default: <code>"RPcirculant"</code>.
</p>
</dd>
<dt><code>size</code></dt><dd><p>vector of 2 components.
Grid size of the simulated stochastic processes.
The two components of the vector correspond to one-dimensional and
two-dimensional processes, respectively.
</p>
<p>Default: <code>c(1024, 64)</code>.
</p>
</dd>
</dl>


<p><b>12. <code>hyper</code>: Options for simulating hyperplane tessellations</b>
</p>

<dl>
<dt><code>mar_distr</code></dt><dd><p>integer.
This argument should not be changed yet.
</p>
<p>It  codes the marginal distribution used in the
simulation:
</p>
<p>0 : uniform distribution<br />
1 : Frechet distribution with form argument <code>mar_param</code><br />
2 : Bernoulli distribution (Binomial with <i>n=1</i>) with
argument <code>mar_param</code>
</p>
<p>Default: <code>0</code> .
</p>
</dd>
<dt><code>mar_param</code></dt><dd><p>Argument used for the marginal
distribution. The argument should not be changed yet.
</p>
<p>Default: <code>NA</code> .
</p>
</dd>
<dt><code>maxlines</code></dt><dd><p>integer.
Maximum number of allowed lines.
</p>
<p>Default: <code>1000</code> .
</p>
</dd>
<dt><code>superpos</code></dt><dd><p>integer.
number of superposed hyperplane tessellations.
</p>
<p>Default: <code>300</code> .
</p>
</dd>
</dl>

<p><b>13. <code>krige</code>: Options for Kriging</b>
</p>

<dl>
<dt><code>cholesky_R</code></dt><dd><p> obsolete </p>
</dd>
<dt><code>fillall</code></dt><dd>
<p>logical value for imputing.
If true all the components are estimated whether they are
<code>NA</code> or not.
</p>
<p>Default: <code>TRUE</code>.
</p>
</dd>
<dt><code>locmaxn</code></dt><dd>
<p>Kriging is conditions on maximal <code>locmaxn</code> points.
If the data contain more points, neighbourhood kriging is performed.
</p>
<p>Default: <code>8000</code>. 
</p>
</dd>
<dt><code>locsplitfactor</code></dt><dd>
<p>In case of neighbourhood kriging, the area is split into small
boxes. The complete neighbourhood contains (2 *
<code>locsplitfactor</code> +1) boxes in each direction.
</p>
<p>Default: <code>2</code>. 
</p>
</dd>
</dl>






<dl>
<dt><code>locsplitn</code></dt><dd><p>vector of 3 components.
A box should contain no more than <code>locsplitn[3]</code>
points, but never less than <code>locsplitn[1]</code>. If
a box had originally less than <code>locsplitn[1]</code> points,
then the box is increased until at least <code>locsplitn[2]</code>
points are in the box.
</p>
<p>Default: <code>c(200, 1000, 5000)</code>. 
</p>
</dd>
<dt><code>method</code></dt><dd><p> obsolete </p>
</dd>
<dt><code>return.variance</code></dt><dd><p>logical.
If <code>FALSE</code> the kriged field is
returned. If <code>TRUE</code> a list of two elements, <code>estim</code> and
<code>var</code>, i.e. the kriged field and the kriging variances,
is returned.
</p>
<p>Default: <code>FALSE</code>. 
</p>
</dd>
</dl>


<p><b>14. <code>maxstable</code>: Options for simulating max-stable random fields</b>
</p>
 
<dl>
<dt><code>check_every</code></dt><dd>
<p>integer. In order to get a precise simulation result, by definition,
the maximum must be taken, for each shape function, over alle
locations of interest. Clearly, small values will not play a role.
To this end, the global minimum has to be determined.
The calculation of the global minimum is expensive and therefor
should not be done too frequently. On the other hand,
rare updates increases the computing times for taking the maximum
over a single shape functions. Here, after every <code>check_every</code>
considered shape function, the global minimum is calculated.
It is expected that a good choice for  <code>check_every</code> is in
in the interval <i>[10, 100]</i>.
</p>
<p>(For ease and for concerns of efficiency, the more adequate, local
minimum is not considered.)
</p>
<p>Default: 30 .
</p>
</dd>
<dt><code>density_ratio</code></dt><dd>
<p>value in <i>[0,1]</i>. This argument is considered only
if <code>flat=-1</code> and the simulation is performed on a grid.
Then, the ratio between the highest and the lowest value is
calculated within the convex hull of the grid. If the
value is less than <code>density_ratio</code> then the grid points
are considered separately. Else the density is considered to be
constant in the convex hull of the grid.
</p>
<p>Default: 0.0.
</p>
</dd>
<dt><code>eps_zhou</code></dt><dd><p>positive real number, which 
gives the aimed relative precision when the constant <i>c</i>
in the paper of Oesting, Schlather, Zhou (2018) has to be estimated.
E.g. if <code>eps_zhou=0.01</code> then the first 2 digits should be
correct.
</p>
<p>Default: 0.01
</p>
</dd>
<dt><code>flathull</code></dt><dd><p><code>NA, FALSE, TRUE</code>. Only used in M3
modelling in the algorithm by Oesting, Schlather, Zhou (2018).
The argument is considered only if the simulation is performed on a
grid. 
If <code>flat=TRUE</code> , then the density
is considered to be <code>flat</code> in the convex hull of the grid,
i.e. the simulation method of Schlather (2002) is used.
If <code>flat=NA</code> the choice is done automatically.
</p>
<p>Default: FALSE .
</p>
</dd>
<dt><code>max_gauss</code></dt><dd>
<p>The simulation of the max-stable process by the old-fashioned
method of Schlather (2002) and by older methods for Brown-Resnick
processes 
uses
a stopping rule that necessarily needs a finite upper endpoint
of the marginal distribution of the random field.
In the case of
<code><a href="RPbrownresnick.html">Brown-Resnick processes</a></code>,
<code><a href="RPschlather.html">extremal Gaussian fields</a></code>,
and
<code><a href="RPopitz.html">extremal t fields</a></code>,
the upper endpoint is approximated by <code>standardmax</code>. 
</p>
<p>Default: <code>3.0</code> .
</p>
</dd>
<dt><code>max_n_zhou</code></dt><dd><p>positive integer.
The overall constant <i>c</i> in the paper of
Oesting, Schlather, Zhou (2018) has to be determined
by MCMC, if the shape functions are random.
</p>
<p>The two arguments, <code>min_n_zhou</code> and <code>max_n_zhou</code>,
give the minimal and the maximal
number of simulations that are performed. To economize
computer time the values of <i>c</i> is partially estimated 
when the shape functions are simulated. If the number
of shape functions is larger than the number of simulations
given by <code>eps_zhou</code> then
no further simulation is performed to determine <i>c</i>.
So, it is advantageous to simulate all fields at once by 
<code>RFsimulate(..., n = )</code>. 
</p>
<p>Default:  1000 and 10000000, respectively.
</p>
</dd>
<dt><code>maxpoints</code></dt><dd>
<p>positive integer; the maximal number of Poisson points to be simulated
for one realization of the max-stable random field. This option will
not be considered for most of the users. This option allows 
the simulation to interrupt after <code>maxpoints</code> shape function
have been placed.
</p>
<p>Default: <code>2e9</code> (never).
</p>
</dd>
<dt><code>mcmc_zhou</code></dt><dd><p>positive integer.
In case of random shape functions, an MCMC step is required.
<code>mcmc_zhou</code>-1 equals the number of members of the MCMC chain
that are left out before the next value of the chain is returned.
</p>
<p>Default: 20
</p>
</dd>
<dt><code>min_n_zhou</code></dt><dd><p>see <code>max_n_zhou</code></p>
</dd>
<dt><code>mcmc_zhou</code></dt><dd><p>positive integer.
In case of random shape functions, an MCMC step is required.
<code>mcmc_zhou</code>-1 equals the number of members of the MCMC chain
that are left out before the next value of the chain is returned.
</p>
<p>Default: 20
</p>
</dd>
<dt><code>min_n_zhou</code></dt><dd><p>see <code>max_n_zhou</code></p>
</dd>
<dt><code>min_shape_gumbel</code></dt><dd><p>To increase speed,
the minimum field value is assumed to be <code>min_shape_gumbel</code>
for calculation of threshold values for simulation short cuts.
During a simulation, its value becomes void as soon as the real
(current) minimum of the field being simulated exceeds
<code>min_shape_gumbel</code>




</p>
<p>Default: <code>-1e15</code>.
</p>
</dd>
<dt><code>scatter_method</code></dt><dd><p>logical. 
If 
</p>
<p>Default: NA;
</p>
</dd>
<dt><code>xi</code></dt><dd>
<p>Extreme value index. Default: <code>2e9</code> .
While <i>&xi;</i> can be set globally, the shift <i>&mu;</i> and the
scale <i>s</i> can be given only locally within the process
definitions, e.g., <code><a href="RPsmith.html">RPsmith</a></code>.
</p>
<p>Default: <code>1.0</code>.
</p>
</dd>
</dl>


<p><b>15. <code>mpp</code>: Options for the random coins (shot noise) methods</b>
</p>

<dl>
<dt><code>about_zero</code></dt><dd>
<p>In certain cases (<a href="RPcoin.html">Coins</a>,<a href="RMtruncsupport.html">RMtruncsupport</a>),
functions are assumed to zero if the value is less than <code>about_zero</code>.
</p>
<p>Default: <code>0.001</code> .
</p>
</dd>
<dt><code>n_estim_E</code></dt><dd><p>integer. Number of draws from the
distribution of the scale to estimate the mean of the distribution.
This is used only if the mean of the scale distribution
is not explicitely given.
Default: <code>50000</code> .
</p>
</dd>
<dt><code>scatter_method</code></dt><dd>
</dd>
<dt><code>scatter_size</code>, <code>scatter_max</code></dt><dd>
<p>Real valued and integer valued, respectively, or <code>NA</code>.
</p>
<p>Used in the internal function <code>RMscatter</code> that calculates
<i>&sum;_{i=1}^n f(x + h_i)</i> for some function <i>f</i> and
for some distances <i>h_i</i>.
</p>

<p>Let <i>\varepsilon=</i><code>about_zero</code>, <i>s=</i><code>scatter_size</code> and <i>m=</i><code>scatter_max</code>.
We distinguish 4 cases:
</p>

<ul>
<li> <p><code>scatter_size &gt; 0</code> and <code>scatter_max &gt;= 0</code><br />
Here, <i>n</i> equals <i>(2m)^d</i>.
and <i>h_i \in M = \{ (k s, &hellip;, k s),&hellip;, (m s, &hellip;, m
	s)\}</i>
with <i>k=-m</i>.
</p>
</li>
<li> <p><code>scatter_size &gt; 0</code> and <code>scatter_max &lt; 0</code><br />
same as the previous case, but <i>m</i> is chosen such that
<i>f(k_i e_i s_i) \approx \varepsilon</i>, <i>-k_i\in N</i>,
<i>i=1,&hellip;,d</i> and 
<i>f(m_i e_i s_i) \approx \varepsilon</i>, <i>m \in N</i>.
</p>
</li>
<li> <p><code>scatter_size &lt;= 0</code> and <code>scatter_max &gt;= 0</code><br />
This option is possible only for grids.
Here <i>h_i</i> runs on the given grid <i>i=1,&hellip;,d</i>,
but at most <code>scatter_max</code> steps.
</p>
</li>
<li> <p><code>scatter_size &lt;= 0</code> and <code>scatter_max &lt; 0</code><br />
this option is possible only for grids.
Here, <i>h_i</i> runs over the whole grid.
</p>
</li></ul>

</dd>
<dt><code>shape_power</code></dt><dd>
<p>Shape functions are powered by <code>shape_power</code> before used as
intensity function for the point process.
</p>
<p>Default: <code>2.0</code>.
</p>
</dd>
</dl>


<p><b>16. <code>nugget</code>: Options for the nugget effect</b><br />
Simulating a nugget effect is per se trivial.
However, it gets complicated
and best methods (including <code>direct</code> and <code>circulant
  embedding</code>!) fail if zonal anisotropies are considered,
where sets of points have to be identified that belong to the
same subspace of eigenvalue 0 of the anisotropy matrix.
</p>

<dl>
<dt><code>tol</code></dt><dd>
<p>The nugget tolerance influences two different kind of models
</p>

<ul>
<li> <p><code><a href="RPnugget.html">RPnugget</a></code>
</p>
</li>
<li> <p><code><a href="QMath.html">R.is</a></code>
</p>
</li></ul>

<p>See there for more information.
</p>
</dd>
</dl>


<p><b>17. <code>registers</code>: Register numbers</b><br />
Model for different purposes are or can be stored at
different places. They are called registers and have non-negative
numbers up to 21 (currently).
The user can use the registers 0..9.
</p>

<dl>
<dt><code>register</code></dt><dd><p>number in 0:9; place where intermediate calculation
for random field simulation are stored; 
the number refers to 10 internal registers 0..9.
</p>
<p>Changing the register number only makes sense, when
two different random fields, say, are to be simulated
alternatingly, several times in a row. Then the
simlulation speed can be increased if several registers
are used, <code>storing=TRUE</code> and <code><a href="RFsimulate.html">RFsimulate</a></code>
is used with the only argument <code>n</code>.
</p>
<p>Default: <code>0</code> 
</p>
</dd> 
</dl>


<p><b>18. <code>sequ</code>: Options for the sequential method</b>
</p>

<dl>
<dt><code>back_steps</code></dt><dd><p>See <code><a href="RPsequential.html">RPsequential</a></code></p>
</dd>
<dt><code>initial</code></dt><dd><p>See <code><a href="RPsequential.html">RPsequential</a></code></p>
</dd>
<dt><code>max_variables</code></dt><dd><p>See <code><a href="RPsequential.html">RPsequential</a></code></p>
</dd>
</dl>


<p><b>19. <code>solve</code>: Options for solving linear systems</b>
</p>

<dl>
<dt><code>det_as_log</code></dt><dd><p>See <a href="../../RandomFieldsUtils/html/RFoptions.html">RFoptions</a> </p>
</dd>
<dt><code>eigen2zero</code></dt><dd><p>See <a href="../../RandomFieldsUtils/html/RFoptions.html">RFoptions</a> </p>
</dd>
<dt><code>max_chol</code></dt><dd><p>integer. Maximum number of rows of a matrix in
a Cholesky decomposition
</p>
<p>Default: <i>8192</i>
</p>
</dd>
<dt><code>max_svd</code></dt><dd><p>integer. Maximum number of rows of a matrix in
a svd decomposition
</p>
<p>Default: <i>6555</i>
</p>
</dd>
<dt><code>pivot</code></dt><dd><p>Type of pivoting for the Cholesky
decomposition. Possible values are 
</p>

<dl>
<dt>PIVOT_NONE</dt><dd><p>No pivoting.</p>
</dd>
<dt>PIVOT_AUTO</dt><dd><p>If the  matrix has a size greater than
3x3 and Choleskey fails without pivoting, privoting
is done. For matrices of size less than 4x4, no pivoting and
no checks are performed.</p>
</dd>
<dt>PIVOT_DO</dt><dd><p>Do alwaoys pivoting.
NOTE: privoted Cholesky decomposition yields only very approximately
an upper triangular matrix L, but still L^t L = M holds true.</p>
</dd>
<dt>PIVOT_IDX</dt><dd><p>uses the same pivoting as in the previous
pivoted decomposition. This option becomes relevant only when
simulations with different parameters or different models shall be
performed with the same seed so that also the pivoting must be
coupled.
</p>
</dd>
</dl>




<p>Default: <code>PIVOT_auto</code></p>
</dd>  
<dt><code>pivot_actual_size</code></dt><dd><p>See <a href="../../RandomFieldsUtils/html/RFoptions.html">RFoptions</a> </p>
</dd>     
<dt><code>pivot_check</code></dt><dd><p>logical. Only used in pivoted Cholesky
decomposition. 
If <code>TRUE</code> and a numerically zero diagonal element is detected,
it is checked whether the offdiagonal elements are numerically zero 
as well.
(See also <code>pivot_max_deviation</code> and
<code>pivot_max_reldeviation</code>.)
if <code>NA</code> then, in  <a href="RPdirect.html">RPdirect</a>, the value is equivent to
</p>

<dl>
<dt><code>FALSE</code></dt><dd><p>if the model is positive (semi-)definite.</p>
</dd>
<dt><code>TRUE</code></dt><dd><p>if the model is genuinely negative definite.</p>
</dd>
</dl>

<p>Default: <code>NA</code>
</p>
</dd>
<dt><code>pivot_idx</code></dt><dd><p>See <a href="../../RandomFieldsUtils/html/RFoptions.html">RFoptions</a></p>
</dd>
<dt><code>pivot_relerror</code></dt><dd><p>See <a href="../../RandomFieldsUtils/html/RFoptions.html">RFoptions</a>  </p>
</dd>    
<dt><code>pivot_max_deviation</code></dt><dd><p>See <a href="../../RandomFieldsUtils/html/RFoptions.html">RFoptions</a> </p>
</dd>    
<dt><code>pivot_max_reldeviation</code></dt><dd><p>See <a href="../../RandomFieldsUtils/html/RFoptions.html">RFoptions</a>  </p>
</dd>   
<dt><code>solve_method</code></dt><dd><p>See <a href="../../RandomFieldsUtils/html/RFoptions.html">RFoptions</a> </p>
</dd>
<dt><code>spam_factor</code></dt><dd><p>See <a href="../../RandomFieldsUtils/html/RFoptions.html">RFoptions</a>  </p>
</dd>    
<dt><code>spam_min_n</code></dt><dd><p>See <a href="../../RandomFieldsUtils/html/RFoptions.html">RFoptions</a>  </p>
</dd>
<dt><code>spam_min_p</code></dt><dd><p>See <a href="../../RandomFieldsUtils/html/RFoptions.html">RFoptions</a>  </p>
</dd>
<dt><code>spam_pivot</code></dt><dd><p>See <a href="../../RandomFieldsUtils/html/RFoptions.html">RFoptions</a></p>
</dd>
<dt><code>spam_sample_n</code></dt><dd><p>See <a href="../../RandomFieldsUtils/html/RFoptions.html">RFoptions</a></p>
</dd>  
<dt><code>spam_tol</code></dt><dd><p>See <a href="../../RandomFieldsUtils/html/RFoptions.html">RFoptions</a></p>
</dd>
<dt><code>svdtol</code></dt><dd><p>See <a href="../../RandomFieldsUtils/html/RFoptions.html">RFoptions</a></p>
</dd>
<dt><code>use_spam</code></dt><dd><p>See <a href="../../RandomFieldsUtils/html/RFoptions.html">RFoptions</a></p>
</dd>
</dl>


<p><b>20. <code>special</code>: Options for specific methods</b>
</p>

<dl>
<dt><code>multicopies</code></dt><dd><p>Only used by <code><a href="RMmult.html">RMmult</a></code>.
The covariance functions are multiplied if the corresponding
independent random fields are multiplied. To get
an approximative Gaussian random fields with a multiplicative
covariance functions the average over <code>multicopies</code>
products of random fields is calculated.
</p>
</dd>
</dl>


<p><b>21. <code>spectral</code>: Options for the spectral (turning bands) method</b>
</p>

<dl>
<dt><code>ergodic</code></dt><dd>
<p>In case of an additive model and <code>ergodic=FALSE</code>,
the additive component are chosen proportional to their
variance. In total <code>lines</code> are simulated. If
<code>ergodic=TRUE</code>, the components are simulated
separately and then added.
</p>
<p>Default: <code>FALSE</code>.
</p>
</dd>
<dt><code>prop_factor</code></dt><dd><p>see <code><a href="RPspectral.html">RPspectral</a></code>
</p>
</dd>
<dt><code>sigma</code></dt><dd><p>see <code><a href="RPspectral.html">RPspectral</a></code>
</p>
</dd>
<dt><code>sp_grid</code></dt><dd><p>   see <code><a href="RPspectral.html">RPspectral</a></code>
</p>
</dd>
<dt><code>sp_lines</code></dt><dd>
<p>see <code><a href="RPspectral.html">RPspectral</a></code>
</p>
</dd>
</dl>


<p><b>22. <code>tbm</code>: Options for the turning bands method</b>
</p>

<dl>
<dt><code>center</code></dt><dd><p>Scalar or vector.
If not <code>NA</code>, the <code>center</code> is used as the center of
the turning bands for <code>TBM2</code> and <code>TBM3</code>.
Otherwise the center is determined
automatically such that the line length is minimal.
See also <code>points</code> and the examples below.
</p>
<p>Default: <code>NA</code> .
</p>
</dd>
<dt><code>fulldim</code></dt><dd>
<p>positiv integer. The dimension of the space into which the
simulated field is embedded. So, the value <code>fulldim</code>
must be at least the dimension of the field.
</p>
<p>Default: 3.
</p>
</dd>
<dt><code>grid</code></dt><dd><p>Logical. 
The angle of the lines is random if
<code>grid=FALSE</code>, 
and <i>k*pi/</i><code>lines</code>
for <i>k</i> in <code>1:lines</code>,
otherwise.
</p>
<p>This option is used by both <code><a href="RPspectral.html">RPspectral</a></code>
and <code><a href="RPtbm.html">RPtbm</a></code>, the latter only when the dimension is 2.
</p>
<p>Default: <code>TRUE</code> .
</p>
</dd>
<dt><code>layers</code></dt><dd>
<p>Logical or integer. If <code>TRUE</code> then the turning layers are used whenever
a time component is given.
If <code>NA</code> the turning layers are used only when the
traditional TBM is not applicable.
If <code>FALSE</code> then turning layers may never be used.
</p>
<p>Default: <code>TRUE</code> .
</p>
</dd>
<dt><code>lines</code></dt><dd>
<p>Number of lines used.
</p>
<p>Default: <code>60</code> .
</p>
</dd>
<dt><code>linesimustep</code></dt><dd>
<p>If <code>linesimustep</code> is positive the grid on the line has lag
<code>linesimustep</code>. 
See also <code>linesimufactor</code>.
</p>
<p>Default: <code>0.0</code> .
</p>
</dd>
<dt><code>linesimufactor</code></dt><dd> <p><code>linesimufactor</code> or
<code>linesimustep</code> must be non-negative; if
<code>linesimustep</code>
is positive then <code>linesimufactor</code> is ignored.
If both
arguments are naught then <code>points</code> is used (and must be
positive).
The grid on the line is <code>linesimufactor</code>-times
finer than the smallest distance. 
See also <code>linesimustep</code>.
</p>
<p>Default: <code>2.0</code> .
</p>
</dd>
<dt><code>points</code></dt><dd><p>integer. If greater than 0,
<code>points</code> gives the number of points simulated on the TBM
line, hence 
must be greater than the minimal number of points given by
the size of the simulated field and the two paramters
<code>TBMx.linesimufactor</code> and <code>TBMx.linesimustep</code>.
If <code>points</code> is not positive the number of points is
determined automatically.
The use of <code>center</code> and <code>points</code> is highlighted
in an example below.
</p>
<p>Default: <code>0</code>.
</p>
</dd>
<dt><code>reduceddim</code></dt><dd>
<p>if positiv integer, then the value itself. If negativ, then
the value is substracted from fulldim.
</p>
<p>Default: <code>-2</code>.
</p>
</dd>
</dl>


<p><b>23. <code>internal</code>: Internal options mostly for warnings and
messages</b>
</p>
<p>All these options should not be changed by the user unless
he/she really known what he/she is doing.
</p>
<p>Most of the options below change their value in a session
without the user's notice.
</p>

<dl>
<dt><code>do_tests</code></dt><dd>
<p>Internal variable. Do not use it.
Default: <code>FALSE</code>.
</p>
</dd>
<dt><code>examples_reduced</code></dt><dd><p>non-negative integer.
If positve, then the design of any simulation in <span class="pkg">RandomFields</span>
is internally reduced in size (roughly downto the given value in each
direction). Warnings report this behaviour.
This option is necessary to run the examples of <span class="pkg">RandomFields</span>
under the time constraint of CRAN.
</p>
</dd>
<dt><code>stored.init</code></dt><dd><p>internally used logical argument.
This option is closely related to 
<code>storing</code> which controls whether intermediate calculations
should be stored to have faster repeated simulations.
</p>
<p>This user option is internally overwritten if the user calls several
simulations at once. This current value is stored in <code>stored.init</code>.
</p>
<p>Default: <code>FALSE</code>.
</p>
</dd>
<dt><code>warn_ambiguous</code></dt><dd><p>internally used logical argument.
Usually, the argument <code>grid</code> in <code><a href="RFsimulate.html">RFsimulate</a></code>,
for instance, can or should be given. If not given,
the system takes a default definition.
Additionally a message is displayed in this case if
<code>ambiguous=TRUE</code>.
</p>
<p>Default: <code>FALSE</code>.
</p>
</dd>
<dt><code>warn_aspect_ratio</code></dt><dd><p>internally used logical argument.
if <code>TRUE</code> then a warning is given not a standard graphical
device is used and the package plots try to keep a certain aspect
ratio. 
</p>
<p>Default: <code>TRUE</code>
</p>
</dd>
<dt><code>warn_colour_palette</code></dt><dd><p>internally used logical argument.
If none of the packages <span class="pkg">RColorBrewer</span> and <span class="pkg">colorspace</span>
are available and graphics are displayed, a message is displayed.
</p>
<p>Default: <code>TRUE</code>.
</p>
</dd>
<dt><code>warn_constant</code></dt><dd>
<p>The definition of <code><a href="RMconstant.html">RMconstant</a></code> has changed.
A warning is displayed if the command is used. <code>warn_constant</code>
will become obsolete in future versions.
</p>
<p>Default: <code>TRUE</code>.
</p>
</dd>
<dt><code>warn_coordinates</code></dt><dd><p>internally used logical argument.
If <code>TRUE</code> then a transformation from earth coordinates to
cartesian coordinates is reported.
</p>
<p>Default: <code>TRUE</code>.
</p>
</dd>
<dt><code>allow_duplicated_locations</code></dt><dd><p>logical.
If <code>FALSE</code> duplicated locations are not allowed.
If <code>TRUE</code> then the (standard) nugget effect becomes a non-stationary
model in an abstract space that cannot be extended outside the given
locations. See also <a href="RMnugget.html">RMnugget</a> for the distinction between
measurement error and spatial nugget.
</p>
<p>Default: <code>FALSE</code>.
</p>
</dd>
<dt><code>warn_missing_zenit</code></dt><dd> 
<p>Only for Earth systems: a missing zenit is frequently a cause
for errors that are difficult to understand. Therefore, in such
cases an additional warning message is displayed.
</p>
<p>Default: <code>TRUE</code>
</p>
</dd>
<dt><code>warn_newAniso</code></dt><dd><p> obsolete.<br />
internally used logical argument.
If <code>newAniso=TRUE</code> and the argument <code>Aniso</code> is used in the model
definition, then a message is displayed that the matrix <code>Aniso</code>
is multiplied from the right by <i>x</i>, where up to Version 2.0
the argument <code>aniso</code> was available which was multiplied from
the left by <i>x</i>.
</p>
<p>Default: <code>TRUE</code>.
</p>
</dd>
</dl>






<dl>
<dt><code>warn_newstyle</code></dt><dd><p>internally used logical argument.
If <code>TRUE</code> a message is displayed the by the argument
<code>spConform=FALSE</code> oldstyle return values are obtained instead
of S4 objects.
</p>
<p>Default: <code>TRUE</code>.
</p>
</dd>
<dt><code>warn_normal_mode</code></dt><dd><p>internally used logical argument.
if <code>TRUE</code> then the function <code><a href="RFfit.html">RFfit</a></code>
displays the message that other values for the option
<code>modus_operandi</code> are available.
</p>
<p>Default: <code>TRUE</code>.
</p>
</dd>
<dt><code>warn_oldstyle</code></dt><dd><p>internally used logical argument.
If <code>TRUE</code> a warning is given if an obsolete function
from Version 2 is used.
</p>
<p>Default: <code>TRUE</code>.
</p>
</dd>
<dt><code>warn_on_grid</code></dt><dd><p>internally used logical argument.
If a (one-dimensional) grid is given, but the argument
<code>grid=FALSE</code>, e.g. in <code>RFsimulate</code>, this contraction is
reported if <code>warn_on_grid=TRUE</code>
</p>
<p>Default: <code>TRUE</code>.
</p>
</dd>
<dt><code>warn_scale</code></dt><dd><p>internally used logical argument.
If <code>warn_scale=TRUE</code> then a scale less than 10 [km] is reported
if earth coordinates are transformed to cartesian coordinates.
</p>
<p>Default: <code>TRUE</code>.
</p>
</dd>
<dt><code>warn_var</code></dt><dd>
<p>In some cases, <span class="pkg">RandomFields</span> cannot detect whether the
variance is non-negative. If <code>TRUE</code> then a warning is displayed
in such a case.
Default: <code>TRUE</code>.
</p>
</dd>
</dl>






















<h3>Value</h3>

<p><code>NULL</code> if any argument is given, and the full list of
arguments, otherwise.
</p>


<h3>Author(s)</h3>

<p>Martin Schlather, <a href="mailto:schlather@math.uni-mannheim.de">schlather@math.uni-mannheim.de</a>, <a href="http://ms.math.uni-mannheim.de">http://ms.math.uni-mannheim.de</a></p>


<h3>References</h3>

<p>Basic
</p>

<ul>
<li><p> General
</p>

<ul>
<li>
<p>Schlather, M. (1999) <em>An introduction to positive definite
functions and to unconditional simulation of random fields.</em>
Technical report ST 99-10, Dept. of Maths and Statistics,
Lancaster University.
</p>
</li>
<li><p> Schlather, M. (2011) Construction of covariance functions and
unconditional simulation of random fields. In Porcu, E., Montero, J.M.
and Schlather, M., <em>Space-Time Processes and Challenges Related
to Environmental Problems.</em> New York: Springer.

</p>
</li></ul>

</li>
<li><p> rectangular distribution; <code>eps_zhou</code>
</p>

<ul>
<li>
<p>Oesting, M., Schlather, M. and Zhou, C. (2013) On the Normalized
Spectral Representation of Max-Stable Processes on a compact set. 
<em>arXiv</em>,  <b>1310.1813</b>
</p>
</li></ul>

</li>
<li> <p><code>shape_power</code>
</p>

<ul>
<li>
<p>Ballani, F. and Schlather, M. (2015) In preparation.
</p>
</li></ul>

</li></ul>



<h3>See Also</h3>

<p><code><a href="RFsimulate.html">RFsimulate</a></code>,
<a href="RFoptionsAdvanced.html">RFoptionsAdvanced</a>,
<code><a href="../../RandomFieldsUtils/html/RFoptions.html">RFoptions</a></code>,
and <code><a href="RFgetMethodNames.html">RFgetMethodNames</a></code>.</p>


<h3>Examples</h3>

<pre>
RFoptions(seed=0) ## *ANY* simulation will have the random seed 0; set
##                   RFoptions(seed=NA) to make them all random again

RFoptions()


############################################################
##                                                        ## 
## use of exactness                                       ##
##                                                        ##
############################################################
x &lt;- seq(0, 1, 1/30)
model &lt;- RMgauss()

for (exactness in c(NA, FALSE, TRUE)) { 
  readline(paste("\n\nexactness: `", exactness, "'; press return"))
  z &lt;- RFsimulate(model, x, x, exactness=exactness,
                  stationary_only=NA, storing=TRUE)
  print(RFgetModelInfo(which="internal")$internal$name)
}

</pre>

<hr /><div style="text-align: center;">[Package <em>RandomFields</em> version 3.3.6 <a href="00Index.html">Index</a>]</div>
</body></html>
