<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Search algorithm in time series graphical models</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for bdgraph.ts {BDgraph}"><tr><td>bdgraph.ts {BDgraph}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>	Search algorithm in time series graphical models </h2>

<h3>Description</h3>

<p>This function is for Bayesian model determination in time series graphical models, based on birth-death MCMC method. 
</p>


<h3>Usage</h3>

<pre>
bdgraph.ts( data, Nlength = NULL, n, iter = 1000, burnin = iter / 2, 
            g.start = "empty", g.space = NULL, prior.df = rep( 3, Nlength ), 
            save.all = FALSE, cores = "all" )
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>data</code></td>
<td>

<p>The aggregate periodogram <i>P_k</i>, which is arranged as a large <i>p x (Nlength*p)</i> matrix <i>[P_1, P_2, ... ,P_Nlength]</i>.
</p>
</td></tr>
<tr valign="top"><td><code>Nlength</code></td>
<td>
<p> The length of the time series. </p>
</td></tr>
<tr valign="top"><td><code>n</code></td>
<td>
<p>The number of observations. </p>
</td></tr>
<tr valign="top"><td><code>iter</code></td>
<td>
<p>The number of iteration for the sampling algorithm.</p>
</td></tr>
<tr valign="top"><td><code>burnin</code></td>
<td>
<p>The number of burn-in iteration for the sampling algorithm.</p>
</td></tr>
<tr valign="top"><td><code>g.start</code></td>
<td>

<p>Corresponds to a starting point of the graph. It could be <code>"empty"</code> (default) and <code>"full"</code>. 
Option <code>"empty"</code> means the initial graph is an empty graph and <code>"full"</code> means a full graph. 
It also could be an object with <code>S3</code> class <code>"bdgraph"</code>; 
with this option we could run the sampling algorithm from the last objects of previous run (see examples).     
</p>
</td></tr> 
<tr valign="top"><td><code>g.space</code></td>
<td>

<p>Corresponds to the sub-space of the graph. 
For the case <code> g.start = "NULL"</code> (default), algorithm search in the hole graph space. 
With this option, one could run the search algorithm only to the restricted subspace of the graph.
Subspace should determine as an adjacency matrix.
</p>
</td></tr> 
<tr valign="top"><td><code>prior.df</code></td>
<td>

<p>The degree of freedom for complex G-Wishart distribution, <i>CW_G(b,D)</i>, which is a prior distribution of the precision matrix in each frequency.
</p>
</td></tr>
<tr valign="top"><td><code>save.all</code></td>
<td>

<p>Logical: if FALSE (default), the adjacency matrices are NOT saved. 
If TRUE, the adjacency matrices after burn-in are saved.
</p>
</td></tr>	
<tr valign="top"><td><code>cores</code></td>
<td>
<p> The number of cores to use for parallel execution. 
The default is to use <code>"all"</code> CPU cores of the computer; 
it can also be a number, e.g. <code>cores=2</code> means 2 CPU cores to use for parallel execution.
</p>
</td></tr>	
</table>


<h3>Value</h3>

<p>An object with <code>S3</code> class <code>"bdgraph"</code> is returned:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>p_links</code></td>
<td>
<p> An upper triangular matrix which corresponds the estimated posterior probabilities of all possible links. </p>
</td></tr>
<tr valign="top"><td><code>K_hat</code></td>
<td>
<p> The posterior estimation of the precision matrix. </p>
</td></tr>
</table>
<p>For the case &quot;save.all = TRUE&quot; is returned:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>sample_graphs</code></td>
<td>
<p> A vector of strings which includes the adjacency matrices of visited graphs after burn-in.</p>
</td></tr>
<tr valign="top"><td><code>graph_weights</code></td>
<td>
<p> A vector which includes the waiting times of visited graphs after burn-in. </p>
</td></tr>
<tr valign="top"><td><code>all_graphs</code></td>
<td>
<p>A vector which includes the identity of the adjacency matrices for all iterations after burn-in. 
It is needed for monitoring the convergence of the BD-MCMC algorithm.</p>
</td></tr>
<tr valign="top"><td><code>all_weights</code></td>
<td>
<p>A vector which includes the waiting times for all iterations after burn-in. It is needed for monitoring the convergence of the BD-MCMC algorithm.</p>
</td></tr>
<tr valign="top"><td><code>status</code></td>
<td>
<p>An integer to indicate the iteration where the algorithm exits, since if the sum of all rates is 0 at some iteration, the graph at this iteration is              regarded as the real graph. It is 0 if the algorithm doesn't exit.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Lang Liu, Nicholas Foti, Alex Tank and Reza Mohammadi </p>


<h3>References</h3>

<p>Tank, A., N. Foti, and E. Fox (2015) Bayesian Structure Learning for Stationary Time Series, , <em>arXiv preprint arXiv:1505.03131</em>
</p>
<p>Mohammadi, A. and E. Wit (2015). Bayesian Structure Learning in Sparse Gaussian Graphical Models, <em>Bayesian Analysis</em>, 10(1):109-138
</p>
<p>Mohammadi, A. and E. Wit (2015). <span class="pkg">BDgraph</span>: An <code>R</code> Package for Bayesian Structure Learning in Graphical Models, <em>arXiv preprint arXiv:1501.05108</em> 
</p>
<p>Mohammadi, A. et al (2017). Bayesian modelling of Dupuytren disease by using Gaussian copula graphical models, <em>Journal of the Royal Statistical Society: Series C</em> 
</p>
<p>Mohammadi, A., Massam H., and G. Letac (2017). The Ratio of Normalizing Constants for Bayesian Graphical Gaussian Model Selection, <em>arXiv preprint arXiv:1706.04416</em> 
</p>
<p>Dobra, A. and A. Mohammadi (2017). Loglinear Model Selection and Human Mobility, <em>arXiv preprint arXiv:1711.02623</em>
</p>


<h3>See Also</h3>

 <p><code><a href="bdgraph.html">bdgraph</a></code> <code><a href="bdgraph.sim.html">bdgraph.sim</a></code>, <code><a href="summary.bdgraph.html">summary.bdgraph</a></code>, and <code><a href="compare.html">compare</a></code> </p>


<h3>Examples</h3>

<pre>
## Not run: 
# Generating time series data
Nlength = 100; N = 150; p = 6; b = 3; threshold = 1e-8;

I                   = diag( p )
A                   = diag( p )
A[ upper.tri( A ) ] = rbinom( p * ( p - 1 ) / 2, 1, 0.2 )
A                   = 0.5 * A

G = matrix( 0, p, p )
K = matrix( 0, p, p * Nlength )

lambda  = seq( 0, Nlength - 1, 1 ) * 2 * pi / Nlength
K0      = matrix( 0, p, p * Nlength )
K_times = matrix( 1, p, p )

for( k in 1:Nlength )
{ # Compute K0
	K0[,(k*p - p + 1):(k*p)] = I + t(A) 
	                  + complex(1,cos(lambda[k]),sin(lambda[k]))*t(A)
	K_times = K_times * ( K0[ , ( k * p - p + 1 ) : ( k * p ) ] != 0 )
	diag( K[ , ( k * p - p + 1 ) : ( k * p ) ] ) = 1
}

G0         = K_times
diag( G0 ) = 0

D = K
d = array( 0, c( p, Nlength, N ) )  # d is the Fourier coefficients of X
x = array( 0, c( p, Nlength, N ) )

for( n in 1:N )
{ # Generate X
	e = matrix( rnorm( p * Nlength ), p, Nlength )
	for( t in 1:Nlength )
		x[ , t, n ] = ifelse( t == 1, e[ , t ], e[ , t ] + A 
}

P = 0 * D
for( n in 1:N )
{   # Compute Pk
	X = x[ , , n ]

	for( i in 1:p ) d[ i, , n ] = fft( X[ i, ] )

	for( i in 1:Nlength ) 
		P[, (i*p-p+1):(i*p)] = P[, (i*p-p+1):(i*p)] + d[, i, n] 
}

bdgraph.obj = bdgraph.ts( P, Nlength, N, iter = 1000 )

summary( bdgraph.obj )
   
compare( G0, bdgraph.obj )	  

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>BDgraph</em> version 2.48 <a href="00Index.html">Index</a>]</div>
</body></html>
