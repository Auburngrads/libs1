<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Parallelized 'lapply'</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for hpc {tm}"><tr><td>hpc {tm}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Parallelized &lsquo;lapply&rsquo;</h2>

<h3>Description</h3>

<p>Parallelize applying a function over a list or vector according to the
registered parallelization engine.
</p>


<h3>Usage</h3>

<pre>
tm_parLapply(X, FUN, ...)
tm_parLapply_engine(new)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>A vector (atomic or list), or other objects suitable for the
engine in use.</p>
</td></tr>
<tr valign="top"><td><code>FUN</code></td>
<td>
<p>the function to be applied to each element of <code>X</code>.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>optional arguments to <code>FUN</code>.</p>
</td></tr>
<tr valign="top"><td><code>new</code></td>
<td>
<p>an object inheriting from class <code>cluster</code> as created
by <code><a href="../../parallel/html/makeCluster.html">makeCluster</a>()</code> from package
<span class="pkg">parallel</span>, or a function with formals <code>X</code>, <code>FUN</code> and
<code>...</code>, or <code>NULL</code> corresponding to the default of using no
parallelization engine.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parallelization can be employed to speed up some of the embarrassingly
parallel computations performed in package <span class="pkg">tm</span>, specifically
<code><a href="tm_filter.html">tm_index</a>()</code>, <code><a href="tm_map.html">tm_map</a>()</code> on a non-lazy-mapped
<code><a href="VCorpus.html">VCorpus</a></code>, and <code><a href="matrix.html">TermDocumentMatrix</a>()</code> on a
<code><a href="VCorpus.html">VCorpus</a></code> or <code><a href="PCorpus.html">PCorpus</a></code>.  Functions
<code>tm_parLapply()</code> and <code>tm_parLapply_engine()</code> can be used to
customize parallelization according to the available resources.
</p>
<p><code>tm_parLapply_engine()</code> is used for getting (with no arguments)
or setting (with argument <code>new</code>) the parallelization engine
employed (see below for examples).
</p>
<p>If an engine is set to an object inheriting from class <code>cluster</code>,
<code>tm_parLapply()</code> calls
<code><a href="../../parallel/html/parLapply.html">parLapply</a>()</code> with this cluster and 
the given arguments.  If set to a function, <code>tm_parLapply()</code>
calls the function with the given arguments.  Otherwise, it simply
calls <code><a href="../../base/html/lapply.html">lapply</a>()</code>.
</p>
<p>Hence, to achieve parallelization via
<code><a href="../../parallel/html/parLapply.html">parLapply</a>()</code>
and a default cluster registered via
<code><a href="../../parallel/html/setDefaultCluster.html">setDefaultCluster</a>()</code>, one
can use </p>
<pre>  tm_parLapply_engine(function(X, FUN, ...)
      parallel::parLapply(NULL, X, FUN, ...))</pre>
<p>or re-register the cluster, say <code>cl</code>, using </p>
<pre>  tm_parLapply_engine(cl)</pre>
<p>(note that there is no mechanism for programmatically getting the
registered default cluster).  Using </p>
<pre>  tm_parLapply_engine(function(X, FUN, ...)
      parallel::parLapplyLB(NULL, X, FUN, ...))</pre>
<p>or </p>
<pre>  tm_parLapply_engine(function(X, FUN, ...)
      parallel::parLapplyLB(cl, X, FUN, ...))</pre>
<p>gives load-balancing parallelization with the registered default or
given cluster, respectively.  To achieve parallelization via forking
(on Unix-alike platforms), one can use the above with clusters created
by <code><a href="../../parallel/html/makeForkCluster.html">makeForkCluster</a>()</code>, or use </p>
<pre>  tm_parLapply_engine(parallel::mclapply)</pre>
<p>or </p>
<pre>  tm_parLapply_engine(function(X, FUN, ...)
      parallel::mclapply(X, FUN, ..., mc.cores = n))</pre>
<p>to use <code><a href="../../parallel/html/mclapply.html">mclapply</a>()</code> with the default or
given number <code>n</code> of cores.
</p>


<h3>Value</h3>

<p>A list the length of <code>X</code>, with the result of applying <code>FUN</code>
together with the <code>...</code> arguments to each element of <code>X</code>.
</p>


<h3>See Also</h3>

<p><code><a href="../../parallel/html/makeCluster.html">makeCluster</a>()</code>,
<code><a href="../../parallel/html/parLapply.html">parLapply</a>()</code>,
<code><a href="../../parallel/html/parLapplyLB.html">parLapplyLB</a>()</code>, and
<code><a href="../../parallel/html/mclapply.html">mclapply</a>()</code>.
</p>

<hr /><div style="text-align: center;">[Package <em>tm</em> version 0.7-5 <a href="00Index.html">Index</a>]</div>
</body></html>
