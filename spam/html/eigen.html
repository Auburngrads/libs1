<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Eigenvalues for Sparse Matrices</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for eigen {spam}"><tr><td>eigen {spam}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Eigenvalues for Sparse Matrices</h2>

<h3>Description</h3>

<p>Functions to calculate eigenvalues and eigenvectors of <code>sparse</code> matrices.
It uses the value of <code>spam.options("inefficiencywarning")</code> to dispatch between <code>base::eigen()</code> or the Implicitly Restarted Arnoldi Process, using 'ARPACK'.
</p>
<p><code>eigen.spam</code> is a wrapper function of <code>eigen_approx</code> and transforms its output to <code>base::eigen</code> like.
</p>


<h3>Usage</h3>

<pre>
eigen.spam(x, nev = 10, symmetric, only.values = FALSE, control = list())
eigen_approx(x, nev, ncv, nitr, mode, only.values = FALSE, verbose = FALSE, f_routine)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>a matrix of class <code>spam</code> whose <code>nev</code> eigenvalues and eigenvectors are to be computed.</p>
</td></tr>
<tr valign="top"><td><code>nev</code></td>
<td>
<p>number of eigenvalues to calculate.</p>
</td></tr>
<tr valign="top"><td><code>symmetric</code></td>
<td>
<p>if TRUE, the matrix is assumed to be symmetric.</p>
</td></tr>
<tr valign="top"><td><code>only.values</code></td>
<td>
<p>if TRUE, only <code>nev</code> eigenvalues are computed and returned, otherwise <code>nev</code> eigenvalues and eigenvectors are returned.</p>
</td></tr>
<tr valign="top"><td><code>control</code></td>
<td>
<p>additional options, see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr valign="top"><td><code>ncv</code></td>
<td>
<p>see &lsquo;Details&rsquo;, use the <code>control</code> option for <code>eigen.spam</code>.</p>
</td></tr>
<tr valign="top"><td><code>nitr</code></td>
<td>
<p>see &lsquo;Details&rsquo;, use the <code>control</code> option for <code>eigen.spam</code>.</p>
</td></tr>
<tr valign="top"><td><code>mode</code></td>
<td>
<p>see &lsquo;Details&rsquo;, use the <code>control</code> option for <code>eigen.spam</code>.</p>
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
<p>see &lsquo;Details&rsquo;, use the <code>control</code> option for <code>eigen.spam</code>.</p>
</td></tr>
<tr valign="top"><td><code>f_routine</code></td>
<td>
<p>only for <code>eigen_approx</code>, to call the Fortran routine for symmetric matrices set this option to &quot;ds_eigen_f&quot; and for non symmetric to &quot;dn_eigen_f&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>mode = "LM"</code>:</dt><dd>
<p>there are different modes available for this function, each mode returns a different range of eigenvalues.
Also the available modes are dependent, whether the input matrix is symmetric or not:
</p>

<dl>
<dt><code>"LM"</code>:</dt><dd><p>Eigenvalues with largest magnitude (sym, non sym), that is, largest eigenvalues in the Euclidean norm of complex numbers.</p>
</dd>
<dt><code>"SM"</code>:</dt><dd><p>Eigenvalues with smallest magnitude (sym, non sym), that is, smallest eigenvalues in the Euclidean norm of complex numbers.</p>
</dd>
<dt><code>"LR"</code>:</dt><dd><p>Eigenvalues with largest real part (non sym).</p>
</dd>
<dt><code>"SR"</code>:</dt><dd><p>Eigenvalues with smallest real part (non sym).</p>
</dd>
<dt><code>"LI"</code>:</dt><dd><p>Eigenvalues with largest imaginary part (non sym).</p>
</dd>
<dt><code>"SI"</code>:</dt><dd><p>Eigenvalues with smallest imaginary part (non sym).</p>
</dd>
<dt><code>"LA"</code>:</dt><dd><p>Eigenvalues with largest algebraic value (sym), that is, largest eigenvalues inclusive of any negative sign.</p>
</dd>
<dt><code>"SA"</code>:</dt><dd><p>Eigenvalues with smallest algebraic value (syn), that is, smallest eigenvalues inclusive of any negative sign.</p>
</dd>
</dl>

</dd></dl>

<dl>
<dt><code>ncv</code>:</dt><dd>
<p>the largest number of basis vectors that will be used in the Implicitly Restarted Arnoldi Process.
Work per major iteration is proportional to x@dimension[1]*ncv*ncv.
The default is set if <code>symmetric</code> to min(x@dimension[1] + 1, max(2 * nev + 1, 200)) or else to min(x@dimension[1] - 1, max(2 * nev + 1, 100)).
Note, this value should not be chosen arbitrary large, but slightly larger than <code>nev</code>.
Otherwise it could lead to memory allocation problems.</p>
</dd>
<dt><code>nitr</code>:</dt><dd>
<p>the maximum number of iterations.
The default is set to <code>ncv + 1000</code></p>
</dd>
<dt><code>spamflag = FALSE</code>:</dt><dd>
<p>if TRUE, the Implicitly Restarted Arnoldi Process is used, independent of the dimension of the respective matrix.</p>
</dd>
<dt><code>verbose = FALSE</code>:</dt><dd>
<p>print additional information.</p>
</dd>
<dt><code>cmplxeps</code>:</dt><dd>
<p>threshold to determine whether a double value is zero, while transforming the ARPACK output to R class complex.
The default is set to <code>.Machine$double.eps</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A vector of the length corresponding to the dimension of the input matrix.
Containing the required <code>nev</code> eigenvalues.
If requested also the corresponding eigenvectors.
In the non symmetric case, the eigenvalues are returned in a matrix with a column containing the real parts and a column containing the imaginary parts of the eigenvalues.
The eigenvectors are then returned in two matrices.</p>


<h3>Note</h3>

<p>The user is advised to choose the <code>control</code> options carefully, see &lsquo;Details&rsquo; for more information.
</p>


<h3>Author(s)</h3>

<p>Roman Flury, Reinhard Furrer</p>


<h3>References</h3>

<p>Lehoucq, R. B. and Sorensen, D. C. and Yang, C. (1997) <em>ARPACK Users Guide: Solution of Large Scale Eigenvalue Problems by Implicitly Restarted Arnoldi Methods</em>.</p>


<h3>See Also</h3>

<p>Option <code>"inefficiencywarning"</code> in <code><a href="options.html">spam.options</a></code> and <code><a href="random.html">spam_random</a></code>.
</p>


<h3>Examples</h3>

<pre>
set.seed(81)
rspam &lt;- spam_random(50^2, density = .0001, spd = TRUE)
SPD &lt;- eigen.spam(rspam, nev = 20, control = list(mode = "SM"),
                  only.values = TRUE)

tail(SPD$values, 20)
isSymmetric(rspam)
# hence the matrix is symmetric positiv definit

rspam2 &lt;- spam_random(50^2, density = .0001, spd = FALSE, sym = TRUE,
                      distribution = rpois, lambda = 2)
SNPDF &lt;- eigen.spam(rspam2, nev = 20, control = list(mode = "SM"),
                    only.values = TRUE)

tail(SNPDF$values, 20)
isSymmetric(rspam2)
# hence the matrix is symmetric but not positiv definit
</pre>

<hr /><div style="text-align: center;">[Package <em>spam</em> version 2.5-0 <a href="00Index.html">Index</a>]</div>
</body></html>
