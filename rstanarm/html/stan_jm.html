<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Bayesian joint longitudinal and time-to-event models via Stan</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for stan_jm {rstanarm}"><tr><td>stan_jm {rstanarm}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Bayesian joint longitudinal and time-to-event models via Stan</h2>

<h3>Description</h3>

<p>Fits a shared parameter joint model for longitudinal and time-to-event 
(e.g. survival) data under a Bayesian framework using Stan.
</p>


<h3>Usage</h3>

<pre>
stan_jm(formulaLong, dataLong, formulaEvent, dataEvent, time_var, id_var,
  family = gaussian, assoc = "etavalue", lag_assoc = 0, grp_assoc,
  epsilon = 1e-05, basehaz = c("bs", "weibull", "piecewise"), basehaz_ops,
  qnodes = 15, init = "prefit", weights, priorLong = normal(),
  priorLong_intercept = normal(), priorLong_aux = cauchy(0, 5),
  priorEvent = normal(), priorEvent_intercept = normal(),
  priorEvent_aux = cauchy(), priorEvent_assoc = normal(),
  prior_covariance = lkj(), prior_PD = FALSE, algorithm = c("sampling",
  "meanfield", "fullrank"), adapt_delta = NULL, max_treedepth = 10L,
  QR = FALSE, sparse = FALSE, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>formulaLong</code></td>
<td>
<p>A two-sided linear formula object describing both the 
fixed-effects and random-effects parts of the longitudinal submodel  
(see <code><a href="../../lme4/html/glmer.html">glmer</a></code> for details). For a multivariate joint 
model (i.e. more than one longitudinal marker) this should 
be a list of such formula objects, with each element
of the list providing the formula for one of the longitudinal submodels.</p>
</td></tr>
<tr valign="top"><td><code>dataLong</code></td>
<td>
<p>A data frame containing the variables specified in
<code>formulaLong</code>. If fitting a multivariate joint model, then this can
be either a single data frame which contains the data for all 
longitudinal submodels, or it can be a list of data frames where each
element of the list provides the data for one of the longitudinal 
submodels.</p>
</td></tr>
<tr valign="top"><td><code>formulaEvent</code></td>
<td>
<p>A two-sided formula object describing the event
submodel. The left hand side of the formula should be a <code>Surv()</code> 
object. See <code><a href="../../survival/html/Surv.html">Surv</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>dataEvent</code></td>
<td>
<p>A data frame containing the variables specified in
<code>formulaEvent</code>.</p>
</td></tr>
<tr valign="top"><td><code>time_var</code></td>
<td>
<p>A character string specifying the name of the variable 
in <code>dataLong</code> which represents time.</p>
</td></tr>
<tr valign="top"><td><code>id_var</code></td>
<td>
<p>A character string specifying the name of the variable in
<code>dataLong</code> which distinguishes between individuals. This can be
left unspecified if there is only one grouping factor (which is assumed
to be the individual). If there is more than one grouping factor (i.e.
clustering beyond the level of the individual) then the <code>id_var</code>
argument must be specified.</p>
</td></tr>
<tr valign="top"><td><code>family</code></td>
<td>
<p>The family (and possibly also the link function) for the 
longitudinal submodel(s). See <code><a href="../../lme4/html/glmer.html">glmer</a></code> for details. 
If fitting a multivariate joint model, then this can optionally be a
list of families, in which case each element of the list specifies the
family for one of the longitudinal submodels.</p>
</td></tr>
<tr valign="top"><td><code>assoc</code></td>
<td>
<p>A character string or character vector specifying the joint
model association structure. Possible association structures that can
be used include: &quot;etavalue&quot; (the default); &quot;etaslope&quot;; &quot;etaauc&quot;; 
&quot;muvalue&quot;; &quot;muslope&quot;; &quot;muauc&quot;; &quot;shared_b&quot;; &quot;shared_coef&quot;; or &quot;null&quot;. 
These are described in the <strong>Details</strong> section below. For a multivariate 
joint model, different association structures can optionally be used for 
each longitudinal submodel by specifying a list of character
vectors, with each element of the list specifying the desired association 
structure for one of the longitudinal submodels. Specifying <code>assoc = NULL</code>
will fit a joint model with no association structure (equivalent  
to fitting separate longitudinal and time-to-event models). It is also 
possible to include interaction terms between the association term 
(&quot;etavalue&quot;, &quot;etaslope&quot;, &quot;muvalue&quot;, &quot;muslope&quot;) and observed data/covariates. 
It is also possible, when fitting a multivariate joint model, to include 
interaction terms between the association terms (&quot;etavalue&quot; or &quot;muvalue&quot;) 
corresponding to the different longitudinal outcomes. See the 
<strong>Details</strong> section as well as the <strong>Examples</strong> below.</p>
</td></tr>
<tr valign="top"><td><code>lag_assoc</code></td>
<td>
<p>A non-negative scalar specifying the time lag that should be
used for the association structure. That is, the hazard of the event at 
time <em>t</em> will be assumed to be associated with the value/slope/auc of 
the longitudinal marker at time <em>t-u</em>, where <em>u</em> is the time lag.
If fitting a multivariate joint model, then a different time lag can be used
for each longitudinal marker by providing a numeric vector of lags, otherwise
if a scalar is provided then the specified time lag will be used for all 
longitudinal markers. Note however that only one time lag  can be specified 
for linking each longitudinal marker to the 
event, and that that time lag will be used for all association structure
types (e.g. <code>"etavalue"</code>, <code>"etaslope"</code>, <code>"etaauc"</code>, 
<code>"muvalue"</code>, etc) that are specified for that longitudinal marker in
the <code>assoc</code> argument.</p>
</td></tr>
<tr valign="top"><td><code>grp_assoc</code></td>
<td>
<p>Character string specifying the method for combining information
across lower level units clustered within an individual when forming the
association structure. This is only relevant when a grouping factor is  
specified in <code>formulaLong</code> that corresponds to clustering within 
individuals. This can be specified as either <code>"sum"</code>, <code>mean</code>,
<code>"min"</code> or <code>"max"</code>. For example, specifying <code>grp_assoc = "sum"</code>
indicates that the association structure should be based on a summation across 
the lower level units clustered within an individual, or specifying
<code>grp_assoc = "mean"</code>  indicates that the association structure 
should be based on the mean (i.e. average) taken across the lower level 
units clustered within an individual.
So, for example, specifying <code>assoc = "muvalue"</code> 
and <code>grp_assoc = "sum"</code> would mean that the log hazard at time 
<em>t</em> for individual <em>i</em> would be linearly related to the sum of
the expected values at time <em>t</em> for each of the lower level 
units (which may be for example tumor lesions) clustered within that 
individual.</p>
</td></tr>
<tr valign="top"><td><code>epsilon</code></td>
<td>
<p>The half-width of the central difference used to numerically
calculate the derivate when the <code>"etaslope"</code> association structure 
is used.</p>
</td></tr>
<tr valign="top"><td><code>basehaz</code></td>
<td>
<p>A character string indicating which baseline hazard to use
for the event submodel. Options are a B-splines approximation estimated 
for the log baseline hazard (<code>"bs"</code>, the default), a Weibull 
baseline hazard (<code>"weibull"</code>, the default), or a piecewise
constant baseline hazard (<code>"piecewise"</code>). (Note however that there  
is currently limited post-estimation functionality available for
models estimated using a piecewise constant baseline hazard).</p>
</td></tr>
<tr valign="top"><td><code>basehaz_ops</code></td>
<td>
<p>A named list specifying options related to the baseline
hazard. Currently this can include: <br />
</p>

<dl>
<dt><code>df</code></dt><dd><p>A positive integer specifying the degrees of freedom 
for the B-splines if <code>basehaz = "bs"</code>, or the number of
intervals used for the piecewise constant baseline hazard if 
<code>basehaz = "piecewise"</code>. The default is 6.</p>
</dd>
<dt><code>knots</code></dt><dd><p>An optional numeric vector specifying the internal knot 
locations for the B-splines if <code>basehaz = "bs"</code>, or the 
internal cut-points for defining intervals of the piecewise constant 
baseline hazard if <code>basehaz = "piecewise"</code>. Knots cannot be
specified if <code>df</code> is specified. If not specified, then the 
default is to use <code>df - 4</code> knots if <code>basehaz = "bs"</code>,
or <code>df - 1</code> knots if <code>basehaz = "piecewise"</code>, which are
placed at equally spaced percentiles of the distribution of
observed event times.</p>
</dd>
</dl>
</td></tr>
<tr valign="top"><td><code>qnodes</code></td>
<td>
<p>The number of nodes to use for the Gauss-Kronrod quadrature
that is used to evaluate the cumulative hazard in the likelihood function. 
Options are 15 (the default), 11 or 7.</p>
</td></tr>
<tr valign="top"><td><code>init</code></td>
<td>
<p>The method for generating the initial values for the MCMC.
The default is <code>"prefit"</code>, which uses those obtained from 
fitting separate longitudinal and time-to-event models prior to 
fitting the joint model. The separate longitudinal model is a 
(possibly multivariate) generalised linear mixed 
model estimated using variational bayes. This is achieved via the 
<code><a href="stan_mvmer.html">stan_mvmer</a></code> function with <code>algorithm = "meanfield"</code>.
The separate Cox model is estimated using <code><a href="../../survival/html/coxph.html">coxph</a></code>. 
This is achieved
using the and time-to-event models prior  
to fitting the joint model. The separate models are estimated using the
<code><a href="../../lme4/html/glmer.html">glmer</a></code> and <code><a href="../../survival/html/coxph.html">coxph</a></code> functions.
This should provide reasonable initial values which should aid the 
MCMC sampler. Parameters that cannot be obtained from 
fitting separate longitudinal and time-to-event models are initialised 
using the &quot;random&quot; method for <code><a href="../../rstan/html/stan.html">stan</a></code>.
However it is recommended that any final analysis should ideally
be performed with several MCMC chains each initiated from a different
set of initial values; this can be obtained by setting
<code>init = "random"</code>. In addition, other possibilities for specifying 
<code>init</code> are the same as those described for <code><a href="../../rstan/html/stan.html">stan</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>weights</code></td>
<td>
<p>Experimental and should be used with caution. The 
user can optionally supply a 2-column data frame containing a set of
'prior weights' to be used in the estimation process. The data frame should
contain two columns: the first containing the IDs for each individual, and 
the second containing the corresponding weights. The data frame should only
have one row for each individual; that is, weights should be constant 
within individuals.</p>
</td></tr>
<tr valign="top"><td><code>priorLong, priorEvent, priorEvent_assoc</code></td>
<td>
<p>The prior distributions for the 
regression coefficients in the longitudinal submodel(s), event submodel,
and the association parameter(s). Can be a call to one of the various functions 
provided by <span class="pkg">rstanarm</span> for specifying priors. The subset of these functions 
that can be used for the prior on the coefficients can be grouped into several 
&quot;families&quot;:
</p>

<table summary="Rd table">
<tr>
 <td style="text-align: left;">
  <strong>Family</strong> </td><td style="text-align: left;"> <strong>Functions</strong> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Student t family</em> </td><td style="text-align: left;"> <code>normal</code>, <code>student_t</code>, <code>cauchy</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Hierarchical shrinkage family</em> </td><td style="text-align: left;"> <code>hs</code>, <code>hs_plus</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Laplace family</em> </td><td style="text-align: left;"> <code>laplace</code>, <code>lasso</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>See the <a href="priors.html">priors help page</a> for details on the families and 
how to specify the arguments for all of the functions in the table above.
To omit a prior &mdash;i.e., to use a flat (improper) uniform prior&mdash;
<code>prior</code> can be set to <code>NULL</code>, although this is rarely a good
idea.
</p>
<p><strong>Note:</strong> Unless <code>QR=TRUE</code>, if <code>prior</code> is from the Student t
family or Laplace family, and if the <code>autoscale</code> argument to the 
function used to specify the prior (e.g. <code><a href="priors.html">normal</a></code>) is left at 
its default and recommended value of <code>TRUE</code>, then the default or 
user-specified prior scale(s) may be adjusted internally based on the scales
of the predictors. See the <a href="priors.html">priors help page</a> for details on
the rescaling and the <code><a href="prior_summary.stanreg.html">prior_summary</a></code> function for a summary of
the priors used for a particular model.</p>
</td></tr>
<tr valign="top"><td><code>priorLong_intercept, priorEvent_intercept</code></td>
<td>
<p>The prior distributions
for the intercepts in the longitudinal submodel(s) and event submodel. 
Can be a call to <code>normal</code>, <code>student_t</code> or 
<code>cauchy</code>. See the <a href="priors.html">priors help page</a> for details on 
these functions. To omit a prior on the intercept &mdash;i.e., to use a flat
(improper) uniform prior&mdash; <code>prior_intercept</code> can be set to
<code>NULL</code>.
</p>
<p><strong>Note:</strong> The prior distribution for the intercept is set so it
applies to the value when all predictors are centered. Moreover, 
note that a prior is only placed on the intercept for the event submodel
when a Weibull baseline hazard has been specified. For the B-splines and
piecewise constant baseline hazards there is not intercept parameter that
is given a prior distribution; an intercept parameter will be shown in 
the output for the fitted model, but this just corresponds to the 
necessary post-estimation adjustment in the linear predictor due to the
centering of the predictiors in the event submodel.</p>
</td></tr>
<tr valign="top"><td><code>priorLong_aux</code></td>
<td>
<p>The prior distribution for the &quot;auxiliary&quot; parameters
in the longitudinal submodels (if applicable). 
The &quot;auxiliary&quot; parameter refers to a different parameter 
depending on the <code>family</code>. For Gaussian models <code>priorLong_aux</code> 
controls <code>"sigma"</code>, the error 
standard deviation. For negative binomial models <code>priorLong_aux</code> controls 
<code>"reciprocal_dispersion"</code>, which is similar to the 
<code>"size"</code> parameter of <code><a href="../../stats/html/rnbinom.html">rnbinom</a></code>:
smaller values of <code>"reciprocal_dispersion"</code> correspond to 
greater dispersion. For gamma models <code>priorLong_aux</code> sets the prior on 
to the <code>"shape"</code> parameter (see e.g., 
<code><a href="../../stats/html/rgamma.html">rgamma</a></code>), and for inverse-Gaussian models it is the 
so-called <code>"lambda"</code> parameter (which is essentially the reciprocal of
a scale parameter). Binomial and Poisson models do not have auxiliary 
parameters. 
</p>
<p><code>priorLong_aux</code> can be a call to <code>exponential</code> to 
use an exponential distribution, or <code>normal</code>, <code>student_t</code> or 
<code>cauchy</code>, which results in a half-normal, half-t, or half-Cauchy 
prior. See <code><a href="priors.html">priors</a></code> for details on these functions. To omit a 
prior &mdash;i.e., to use a flat (improper) uniform prior&mdash; set 
<code>priorLong_aux</code> to <code>NULL</code>.
</p>
<p>If fitting a multivariate joint model, you have the option to
specify a list of prior distributions, however the elements of the list
that correspond to any longitudinal submodel which does not have an 
auxiliary parameter will be ignored.</p>
</td></tr>
<tr valign="top"><td><code>priorEvent_aux</code></td>
<td>
<p>The prior distribution for the &quot;auxiliary&quot; parameters
in the event submodel. The &quot;auxiliary&quot; parameters refers to different  
parameters depending on the baseline hazard. For <code>basehaz = "weibull"</code>
the auxiliary parameter is the Weibull shape parameter. For 
<code>basehaz = "bs"</code> the auxiliary parameters are the coefficients for the
B-spline approximation to the log baseline hazard.
For <code>basehaz = "piecewise"</code> the auxiliary parameters are the piecewise
estimates of the log baseline hazard.</p>
</td></tr>
<tr valign="top"><td><code>prior_covariance</code></td>
<td>
<p>Cannot be <code>NULL</code>; see <code><a href="priors.html">priors</a></code> for
more information about the prior distributions on covariance matrices.
Note however that the default prior for covariance matrices in 
<code>stan_jm</code> is slightly different to that in <code><a href="stan_glmer.html">stan_glmer</a></code> 
(the details of which are described on the <code><a href="priors.html">priors</a></code> page).</p>
</td></tr>
<tr valign="top"><td><code>prior_PD</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to draw from the prior predictive distribution instead of
conditioning on the outcome.</p>
</td></tr>
<tr valign="top"><td><code>algorithm</code></td>
<td>
<p>A string (possibly abbreviated) indicating the 
estimation approach to use. Can be <code>"sampling"</code> for MCMC (the
default), <code>"optimizing"</code> for optimization, <code>"meanfield"</code> for
variational inference with independent normal distributions, or
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution. See <code><a href="rstanarm-package.html">rstanarm-package</a></code> for more details on the
estimation algorithms. NOTE: not all fitting functions support all four
algorithms.</p>
</td></tr>
<tr valign="top"><td><code>adapt_delta</code></td>
<td>
<p>Only relevant if <code>algorithm="sampling"</code>. See 
<code><a href="adapt_delta.html">adapt_delta</a></code> for details.</p>
</td></tr>
<tr valign="top"><td><code>max_treedepth</code></td>
<td>
<p>A positive integer specifying the maximum treedepth 
for the non-U-turn sampler. See the <code>control</code> argument in 
<code><a href="../../rstan/html/stan.html">stan</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>QR</code></td>
<td>
<p>A logical scalar defaulting to <code>FALSE</code>, but if <code>TRUE</code> 
applies a scaled <code><a href="../../Matrix/html/qr-methods.html">qr</a></code> decomposition to the design matrix, 
<i>X = Q* R*</i>, where <i>Q* = 
Q (n-1)^0.5</i> and <i>R* = (n-1)^(-0.5) 
R</i>. The coefficients relative to <i>Q*</i> are obtained and then 
premultiplied by the inverse of <i>R*</i> to obtain coefficients 
relative to the original predictors, <i>X</i>. These transformations do not 
change the likelihood of the data but are recommended for computational 
reasons when there are multiple predictors. Importantly, while the columns
of <i>X</i> are almost always correlated, the columns of <i>Q*</i>
are uncorrelated by design, which often makes sampling from the posterior
easier. However, because when <code>QR</code> is <code>TRUE</code> the <code>prior</code>
argument applies to the coefficients relative to <i>Q*</i> (and
those are not very interpretable), setting <code>QR=TRUE</code> is only
recommended if you do not have an informative prior for the regression
coefficients. 
</p>
<p>For more details see the Stan case study 
<em>The QR Decomposition For Regression Models</em> at 
<a href="http://mc-stan.org/users/documentation/case-studies/qr_regression.html">http://mc-stan.org/users/documentation/case-studies/qr_regression.html</a>.</p>
</td></tr>
<tr valign="top"><td><code>sparse</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to use a sparse representation of the design (X) matrix. 
If <code>TRUE</code>, the the design matrix is not centered (since that would 
destroy the sparsity) and likewise it is not possible to specify both 
<code>QR = TRUE</code> and <code>sparse = TRUE</code>. Depending on how many zeros
there are in the design matrix, setting <code>sparse = TRUE</code> may make
the code run faster and can consume much less RAM.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Further arguments passed to the function in the <span class="pkg">rstan</span> 
package (<code><a href="../../rstan/html/sampling.html">sampling</a></code>, <code><a href="../../rstan/html/vb.html">vb</a></code>, or 
<code><a href="../../rstan/html/optimizing.html">optimizing</a></code>), corresponding to the estimation method 
named by <code>algorithm</code>. For example, if <code>algorithm</code> is
<code>"sampling"</code> it is possibly to specify <code>iter</code>, <code>chains</code>,
<code>cores</code>, <code>refresh</code>, etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stan_jm</code> function can be used to fit a joint model (also 
known as a shared parameter model) for longitudinal and time-to-event data 
under a Bayesian framework. The underlying
estimation is carried out using the Bayesian C++ package Stan 
(<a href="http://mc-stan.org/">http://mc-stan.org/</a>). <br />
<br /> 
The joint model may be univariate (with only one longitudinal submodel) or
multivariate (with more than one longitudinal submodel). 
For the longitudinal submodel a (possibly multivariate) generalised linear 
mixed model is assumed with any of the <code><a href="../../stats/html/family.html">family</a></code> choices 
allowed by <code><a href="../../lme4/html/glmer.html">glmer</a></code>. If a multivariate joint model is specified 
(by providing a list of formulas in the <code>formulaLong</code> argument), then
the multivariate longitudinal submodel consists of a multivariate generalized  
linear model (GLM) with group-specific terms that are assumed to be correlated
across the different GLM submodels. That is, within
a grouping factor (for example, patient ID) the group-specific terms are
assumed to be correlated across the different GLM submodels. It is 
possible to specify a different outcome type (for example a different
family and/or link function) for each of the GLM submodels, by providing
a list of <code><a href="../../stats/html/family.html">family</a></code> objects in the <code>family</code> 
argument. Multi-level 
clustered data are allowed, and that additional clustering can occur at a 
level higher than the individual-level (e.g. patients clustered within 
clinics), or at a level lower than the individual-level (e.g. tumor lesions
clustered within patients). If the clustering occurs at a level lower than
the individual, then the user needs to indicate how the lower level 
clusters should be handled when forming the association structure between
the longitudinal and event submodels (see the <code>grp_assoc</code> argument
described above). <br />
<br />
For the event submodel a parametric
proportional hazards model is assumed. The baseline hazard can be estimated 
using either a cubic B-splines approximation (<code>basehaz = "bs"</code>, the
default), a Weibull distribution (<code>basehaz = "weibull"</code>), or a
piecewise constant baseline hazard (<code>basehaz = "piecewise"</code>).
If the B-spline or piecewise constant baseline hazards are used, 
then the degrees of freedom or the internal knot locations can be 
(optionally) specified. If
the degrees of freedom are specified (through the <code>df</code> argument) then
the knot locations are automatically generated based on the 
distribution of the observed event times (not including censoring times). 
Otherwise internal knot locations can be specified 
directly through the <code>knots</code> argument. If neither <code>df</code> or
<code>knots</code> is specified, then the default is to set <code>df</code> equal to 6.
It is not possible to specify both <code>df</code> and <code>knots</code>. <br />
<br />
Time-varying covariates are allowed in both the 
longitudinal and event submodels. These should be specified in the data 
in the same way as they normally would when fitting a separate 
longitudinal model using <code><a href="../../lme4/html/lmer.html">lmer</a></code> or a separate 
time-to-event model using <code><a href="../../survival/html/coxph.html">coxph</a></code>. These time-varying
covariates should be exogenous in nature, otherwise they would perhaps 
be better specified as an additional outcome (i.e. by including them as an 
additional longitudinal outcome in the joint model). <br />
<br />
Bayesian estimation of the joint model is performed via MCMC. The Bayesian  
model includes independent priors on the 
regression coefficients for both the longitudinal and event submodels, 
including the association parameter(s) (in much the same way as the
regression parameters in <code><a href="stan_glm.html">stan_glm</a></code>) and
priors on the terms of a decomposition of the covariance matrices of the
group-specific parameters. 
See <code><a href="priors.html">priors</a></code> for more information about the priors distributions
that are available. <br />
<br />
Gauss-Kronrod quadrature is used to numerically evaluate the integral  
over the cumulative hazard in the likelihood function for the event submodel.
The accuracy of the numerical approximation can be controlled using the
number of quadrature nodes, specified through the <code>qnodes</code> 
argument. Using a higher number of quadrature nodes will result in a more 
accurate approximation.
</p>


<h4>Association structures</h4>

<p>The association structure for the joint model can be based on any of the 
following parameterisations: 
</p>

<ul>
<li><p> current value of the linear predictor in the 
longitudinal submodel (<code>"etavalue"</code>) 
</p>
</li>
<li><p> first derivative (slope) of the linear predictor in the 
longitudinal submodel (<code>"etaslope"</code>) 
</p>
</li>
<li><p> the area under the curve of the linear predictor in the 
longitudinal submodel (<code>"etaauc"</code>) 
</p>
</li>
<li><p> current expected value of the longitudinal submodel 
(<code>"muvalue"</code>)
</p>
</li>
<li><p> the area under the curve of the expected value from the 
longitudinal submodel (<code>"muauc"</code>)
</p>
</li>
<li><p> shared individual-level random effects (<code>"shared_b"</code>) 
</p>
</li>
<li><p> shared individual-level random effects which also incorporate 
the corresponding fixed effect as well as any corresponding 
random effects for clustering levels higher than the individual)
(<code>"shared_coef"</code>)
</p>
</li>
<li><p> interactions between association terms and observed data/covariates
(<code>"etavalue_data"</code>, <code>"etaslope_data"</code>, <code>"muvalue_data"</code>, 
<code>"muslope_data"</code>). These are described further below.
</p>
</li>
<li><p> interactions between association terms corresponding to different 
longitudinal outcomes in a multivariate joint model 
(<code>"etavalue_etavalue(#)"</code>, <code>"etavalue_muvalue(#)"</code>,
<code>"muvalue_etavalue(#)"</code>, <code>"muvalue_muvalue(#)"</code>). These
are described further below.      
</p>
</li>
<li><p> no association structure (equivalent to fitting separate 
longitudinal and event models) (<code>"null"</code> or <code>NULL</code>) 
</p>
</li></ul>

<p>More than one association structure can be specified, however,
not all possible combinations are allowed.   
Note that for the lagged association structures baseline values (time = 0) 
are used for the instances 
where the time lag results in a time prior to baseline. When using the 
<code>"etaauc"</code> or <code>"muauc"</code> association structures, the area under
the curve is evaluated using Gauss-Kronrod quadrature with 15 quadrature 
nodes. By default, <code>"shared_b"</code> and <code>"shared_coef"</code> contribute 
all random effects to the association structure; however, a subset of the 
random effects can be chosen by specifying their indices between parentheses 
as a suffix, for example, <code>"shared_b(1)"</code> or <code>"shared_b(1:3)"</code> or 
<code>"shared_b(1,2,4)"</code>, and so on. <br />
<br /> 
In addition, several association terms (<code>"etavalue"</code>, <code>"etaslope"</code>,
<code>"muvalue"</code>, <code>"muslope"</code>) can be interacted with observed 
data/covariates. To do this, use the association term's main handle plus a
suffix of <code>"_data"</code> then followed by the model matrix formula in 
parentheses. For example if we had a variable in our dataset for gender 
named <code>sex</code> then we might want to obtain different estimates for the 
association between the current slope of the marker and the risk of the 
event for each gender. To do this we would specify 
<code>assoc = c("etaslope", "etaslope_data(~ sex)")</code>. <br />
<br />
It is also possible, when fitting  a multivariate joint model, to include 
interaction terms between the association terms themselves (this only
applies for interacting <code>"etavalue"</code> or <code>"muvalue"</code>). For example, 
if we had a joint model with two longitudinal markers, we could specify 
<code>assoc = list(c("etavalue", "etavalue_etavalue(2)"), "etavalue")</code>.
The first element of list says we want to use the value of the linear
predictor for the first marker, as well as it's interaction with the
value of the linear predictor for the second marker. The second element of 
the list says we want to also include the expected value of the second marker 
(i.e. as a &quot;main effect&quot;). Therefore, the linear predictor for the event 
submodel would include the &quot;main effects&quot; for each marker as well as their
interaction. <br />
<br />
There are additional examples in the <strong>Examples</strong> section below.
</p>



<h3>Value</h3>

<p>A <a href="stanreg-objects.html">stanjm</a> object is returned.
</p>


<h3>See Also</h3>

<p><code><a href="stanreg-objects.html">stanreg-objects</a></code>, <code><a href="stanmvreg-methods.html">stanmvreg-methods</a></code>, 
<code><a href="print.stanreg.html">print.stanmvreg</a></code>, <code><a href="summary.stanreg.html">summary.stanmvreg</a></code>,
<code><a href="posterior_traj.html">posterior_traj</a></code>, <code><a href="posterior_survfit.html">posterior_survfit</a></code>, 
<code><a href="posterior_predict.stanreg.html">posterior_predict</a></code>, <code><a href="posterior_interval.stanreg.html">posterior_interval</a></code>,
<code><a href="pp_check.stanreg.html">pp_check</a></code>, <code><a href="ps_check.html">ps_check</a></code>, <code><a href="stan_mvmer.html">stan_mvmer</a></code>.
</p>


<h3>Examples</h3>

<pre>

#####
# Univariate joint model, with association structure based on the 
# current value of the linear predictor
f1 &lt;- stan_jm(formulaLong = logBili ~ year + (1 | id), 
              dataLong = pbcLong,
              formulaEvent = Surv(futimeYears, death) ~ sex + trt, 
              dataEvent = pbcSurv,
              time_var = "year",
              # this next line is only to keep the example small in size!
              chains = 1, cores = 1, seed = 12345, iter = 1000)
print(f1) 
summary(f1) 
        
#####
# Univariate joint model, with association structure based on the 
# current value and slope of the linear predictor
f2 &lt;- stan_jm(formulaLong = logBili ~ year + (year | id), 
              dataLong = pbcLong,
              formulaEvent = Surv(futimeYears, death) ~ sex + trt, 
              dataEvent = pbcSurv,
              assoc = c("etavalue", "etaslope"),
              time_var = "year",
              chains = 1, cores = 1, seed = 12345, iter = 1000)
print(f2)  

#####
# Univariate joint model, with association structure based on the 
# lagged value of the linear predictor, where the lag is 2 time 
# units (i.e. 2 years in this example)
f3 &lt;- stan_jm(formulaLong = logBili ~ year + (1 | id), 
              dataLong = pbcLong,
              formulaEvent = Surv(futimeYears, death) ~ sex + trt, 
              dataEvent = pbcSurv,
              time_var = "year",
              assoc = "etavalue", lag_assoc = 2,
              chains = 1, cores = 1, seed = 12345, iter = 1000)
print(f3) 

#####
# Univariate joint model, where the association structure includes 
# interactions with observed data. Here we specify that we want to use 
# an association structure based on the current value of the linear 
# predictor from the longitudinal submodel (i.e. "etavalue"), but we 
# also want to interact this with the treatment covariate (trt) from
# pbcLong data frame, so that we can estimate a different association 
# parameter (i.e. estimated effect of log serum bilirubin on the log 
# hazard of death) for each treatment group
f4 &lt;- stan_jm(formulaLong = logBili ~ year + (1 | id), 
              dataLong = pbcLong,
              formulaEvent = Surv(futimeYears, death) ~ sex + trt, 
              dataEvent = pbcSurv,
              time_var = "year",
              assoc = c("etavalue", "etavalue_data(~ trt)"),
              chains = 1, cores = 1, seed = 12345, iter = 1000)
print(f4)

######
# Multivariate joint model, with association structure based 
# on the current value and slope of the linear predictor in the 
# first longitudinal submodel and the area under the marker 
# trajectory for the second longitudinal submodel
mv1 &lt;- stan_jm(
        formulaLong = list(
          logBili ~ year + (1 | id), 
          albumin ~ sex + year + (year | id)),
        dataLong = pbcLong,
        formulaEvent = Surv(futimeYears, death) ~ sex + trt, 
        dataEvent = pbcSurv,
        assoc = list(c("etavalue", "etaslope"), "etaauc"), 
        time_var = "year",
        chains = 1, cores = 1, seed = 12345, iter = 100)
print(mv1)

#####
# Multivariate joint model, where the association structure is formed by 
# including the expected value of each longitudinal marker (logBili and 
# albumin) in the linear predictor of the event submodel, as well as their 
# interaction effect (i.e. the interaction between the two "etavalue" terms). 
# Note that whether such an association structure based on a marker by 
# marker interaction term makes sense will depend on the context of your 
# application -- here we just show it for demostration purposes).
mv2 &lt;- stan_jm(
        formulaLong = list(
          logBili ~ year + (1 | id), 
          albumin ~ sex + year + (year | id)),
        dataLong = pbcLong,
        formulaEvent = Surv(futimeYears, death) ~ sex + trt, 
        dataEvent = pbcSurv,
        assoc = list(c("etavalue", "etavalue_etavalue(2)"), "etavalue"),
        time_var = "year", 
        chains = 1, cores = 1, seed = 12345, iter = 100)
        
#####
# Multivariate joint model, with one bernoulli marker and one
# Gaussian marker. We will artificially create the bernoulli
# marker by dichotomising log serum bilirubin
pbcLong$ybern &lt;- as.integer(pbcLong$logBili &gt;= mean(pbcLong$logBili))
mv3 &lt;- stan_jm(
        formulaLong = list(
          ybern ~ year + (1 | id), 
          albumin ~ sex + year + (year | id)),
        dataLong = pbcLong,
        formulaEvent = Surv(futimeYears, death) ~ sex + trt, 
        dataEvent = pbcSurv,
        family = list(binomial, gaussian),
        time_var = "year", 
        chains = 1, cores = 1, seed = 12345, iter = 1000)


</pre>

<hr /><div style="text-align: center;">[Package <em>rstanarm</em> version 2.17.2 <a href="00Index.html">Index</a>]</div>
</body></html>
