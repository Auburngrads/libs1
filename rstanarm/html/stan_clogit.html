<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Conditional logistic (clogit) models via Stan</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for stan_clogit {rstanarm}"><tr><td>stan_clogit {rstanarm}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Conditional logistic (clogit) models via Stan</h2>

<h3>Description</h3>

<p>A model for case-control studies with optional prior distributions for the
coefficients, intercept, and auxiliary parameters.
</p>


<h3>Usage</h3>

<pre>
stan_clogit(formula, data, subset, na.action = NULL, ..., strata,
  prior = normal(), prior_covariance = decov(), prior_PD = FALSE,
  algorithm = c("sampling", "optimizing", "meanfield", "fullrank"),
  adapt_delta = NULL, QR = FALSE, sparse = FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>formula, data, subset, na.action</code></td>
<td>
<p>Same as for <code><a href="../../lme4/html/glmer.html">glmer</a></code>, 
except that any intercept included in the formula will be dropped. <em>We
strongly advise against omitting the <code>data</code> argument</em>. Unless 
<code>data</code> is specified (and is a data frame) many post-estimation 
functions (including <code>update</code>, <code>loo</code>, <code>kfold</code>) are not 
guaranteed to work properly.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Further arguments passed to the function in the <span class="pkg">rstan</span> 
package (<code><a href="../../rstan/html/sampling.html">sampling</a></code>, <code><a href="../../rstan/html/vb.html">vb</a></code>, or 
<code><a href="../../rstan/html/optimizing.html">optimizing</a></code>), corresponding to the estimation method 
named by <code>algorithm</code>. For example, if <code>algorithm</code> is
<code>"sampling"</code> it is possibly to specify <code>iter</code>, <code>chains</code>,
<code>cores</code>, <code>refresh</code>, etc.</p>
</td></tr>
<tr valign="top"><td><code>strata</code></td>
<td>
<p>A factor indicating the groups in the data where the number of 
successes (possibly one) is fixed by the research design. It may be useful 
to use <code><a href="../../base/html/interaction.html">interaction</a></code> or <code><a href="../../survival/html/strata.html">strata</a></code> to
create this factor. However, the <code>strata</code> argument must not rely on
any object besides the <code>data</code> <code><a href="../../base/html/data.frame.html">data.frame</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>prior</code></td>
<td>
<p>The prior distribution for the regression coefficients. 
<code>prior</code> should be a call to one of the various functions provided by 
<span class="pkg">rstanarm</span> for specifying priors. The subset of these functions that 
can be used for the prior on the coefficients can be grouped into several 
&quot;families&quot;:
</p>

<table summary="Rd table">
<tr>
 <td style="text-align: left;">
  <strong>Family</strong> </td><td style="text-align: left;"> <strong>Functions</strong> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Student t family</em> </td><td style="text-align: left;"> <code>normal</code>, <code>student_t</code>, <code>cauchy</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Hierarchical shrinkage family</em> </td><td style="text-align: left;"> <code>hs</code>, <code>hs_plus</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Laplace family</em> </td><td style="text-align: left;"> <code>laplace</code>, <code>lasso</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <em>Product normal family</em> </td><td style="text-align: left;"> <code>product_normal</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>See the <a href="priors.html">priors help page</a> for details on the families and 
how to specify the arguments for all of the functions in the table above.
To omit a prior &mdash;i.e., to use a flat (improper) uniform prior&mdash;
<code>prior</code> can be set to <code>NULL</code>, although this is rarely a good
idea.
</p>
<p><strong>Note:</strong> Unless <code>QR=TRUE</code>, if <code>prior</code> is from the Student t
family or Laplace family, and if the <code>autoscale</code> argument to the 
function used to specify the prior (e.g. <code><a href="priors.html">normal</a></code>) is left at 
its default and recommended value of <code>TRUE</code>, then the default or 
user-specified prior scale(s) may be adjusted internally based on the
scales of the predictors. See the <a href="priors.html">priors help page</a> and the
<em>Prior Distributions</em> vignette for details on the rescaling and the
<code><a href="prior_summary.stanreg.html">prior_summary</a></code> function for a summary of the priors used for a
particular model.</p>
</td></tr>
<tr valign="top"><td><code>prior_covariance</code></td>
<td>
<p>Cannot be <code>NULL</code> when lme4-style group-specific
terms are included in the <code>formula</code>. See <code><a href="priors.html">decov</a></code> for
more information about the default arguments. Ignored when there are no
group-specific terms.</p>
</td></tr>
<tr valign="top"><td><code>prior_PD</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to draw from the prior predictive distribution instead of
conditioning on the outcome.</p>
</td></tr>
<tr valign="top"><td><code>algorithm</code></td>
<td>
<p>A string (possibly abbreviated) indicating the 
estimation approach to use. Can be <code>"sampling"</code> for MCMC (the
default), <code>"optimizing"</code> for optimization, <code>"meanfield"</code> for
variational inference with independent normal distributions, or
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution. See <code><a href="rstanarm-package.html">rstanarm-package</a></code> for more details on the
estimation algorithms. NOTE: not all fitting functions support all four
algorithms.</p>
</td></tr>
<tr valign="top"><td><code>adapt_delta</code></td>
<td>
<p>Only relevant if <code>algorithm="sampling"</code>. See 
<code><a href="adapt_delta.html">adapt_delta</a></code> for details.</p>
</td></tr>
<tr valign="top"><td><code>QR</code></td>
<td>
<p>A logical scalar defaulting to <code>FALSE</code>, but if <code>TRUE</code> 
applies a scaled <code><a href="../../Matrix/html/qr-methods.html">qr</a></code> decomposition to the design matrix, 
<i>X = Q* R*</i>, where <i>Q* = 
Q (n-1)^0.5</i> and <i>R* = (n-1)^(-0.5) 
R</i>. The coefficients relative to <i>Q*</i> are obtained and then 
premultiplied by the inverse of <i>R*</i> to obtain coefficients 
relative to the original predictors, <i>X</i>. These transformations do not 
change the likelihood of the data but are recommended for computational 
reasons when there are multiple predictors. Importantly, while the columns
of <i>X</i> are almost always correlated, the columns of <i>Q*</i>
are uncorrelated by design, which often makes sampling from the posterior
easier. However, because when <code>QR</code> is <code>TRUE</code> the <code>prior</code>
argument applies to the coefficients relative to <i>Q*</i> (and
those are not very interpretable), setting <code>QR=TRUE</code> is only
recommended if you do not have an informative prior for the regression
coefficients. 
</p>
<p>For more details see the Stan case study 
<em>The QR Decomposition For Regression Models</em> at 
<a href="http://mc-stan.org/users/documentation/case-studies/qr_regression.html">http://mc-stan.org/users/documentation/case-studies/qr_regression.html</a>.</p>
</td></tr>
<tr valign="top"><td><code>sparse</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to use a sparse representation of the design (X) matrix. 
If <code>TRUE</code>, the the design matrix is not centered (since that would 
destroy the sparsity) and likewise it is not possible to specify both 
<code>QR = TRUE</code> and <code>sparse = TRUE</code>. Depending on how many zeros
there are in the design matrix, setting <code>sparse = TRUE</code> may make
the code run faster and can consume much less RAM.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stan_clogit</code> function is mostly similar in syntax to 
<code><a href="../../survival/html/clogit.html">clogit</a></code> but rather than performing maximum
likelihood estimation of generalized linear models, full Bayesian
estimation is performed (if <code>algorithm</code> is <code>"sampling"</code>) via
MCMC. The Bayesian model adds priors (independent by default) on the
coefficients of the GLM.
</p>
<p>The <code>data.frame</code> passed to the <code>data</code> argument must be sorted by 
the variable passed to the <code>strata</code> argument.
</p>
<p>The <code>formula</code> may have group-specific terms like in 
<code><a href="stan_glmer.html">stan_glmer</a></code> but should not allow the intercept to vary by the
stratifying variable, since there is no information in the data with which
to estimate such deviations in the intercept.
</p>


<h3>Value</h3>

<p>A <a href="stanreg-objects.html">stanreg</a> object is returned 
for <code>stan_clogit</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stanreg-methods.html">stanreg-methods</a></code> and 
<code><a href="../../survival/html/clogit.html">clogit</a></code>.
</p>
<p>The vignette for Bernoulli and binomial models.
</p>


<h3>Examples</h3>

<pre>
post &lt;- stan_clogit(case ~ spontaneous + induced + (1 | education), 
                    strata = stratum,
                    data = infert[order(infert$stratum), ],
                    subset = parity &lt;= 2,
                    QR = TRUE,
                    chains = 2, iter = 500) # for speed only

nd &lt;- infert[infert$parity &gt; 2, c("case", "spontaneous", "induced", 
                                  "education", "stratum")]
# next line would fail without case and stratum variables                                 
pr &lt;- posterior_linpred(post, newdata = nd, transform = TRUE)
all.equal(rep(sum(nd$case), nrow(pr)), rowSums(pr)) # not a random variable
            
</pre>

<hr /><div style="text-align: center;">[Package <em>rstanarm</em> version 2.17.2 <a href="00Index.html">Index</a>]</div>
</body></html>
