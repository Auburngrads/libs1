<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Prior distributions and options</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for priors {rstanarm}"><tr><td>priors {rstanarm}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Prior distributions and options</h2>

<h3>Description</h3>

<p>The functions described on this page are used to specify the prior-related 
arguments of the various modeling functions in the <span class="pkg">rstanarm</span> package (to
view the priors used for an existing model see <code><a href="prior_summary.stanreg.html">prior_summary</a></code>). 
More information on priors is also available in the <em>Prior 
Distributions</em> vignette as well as the vignettes for the various modeling 
functions. The default priors used in the various <span class="pkg">rstanarm</span> modeling
functions are intended to be <em>weakly informative</em> in that they provide
moderate regularlization and help stabilize computation. For many
applications the defaults will perform well, but prudent use of more
informative priors is encouraged. Uniform prior distributions are possible
(e.g. by setting <code><a href="stan_glm.html">stan_glm</a></code>'s <code>prior</code> argument to
<code>NULL</code>) but, unless the data is very strong, they are not recommended
and are <em>not</em> non-informative, giving the same probability mass to
implausible values as plausible ones.
</p>


<h3>Usage</h3>

<pre>
normal(location = 0, scale = NULL, autoscale = TRUE)

student_t(df = 1, location = 0, scale = NULL, autoscale = TRUE)

cauchy(location = 0, scale = NULL, autoscale = TRUE)

hs(df = 1, global_df = 1, global_scale = 0.01, slab_df = 4,
  slab_scale = 2.5)

hs_plus(df1 = 1, df2 = 1, global_df = 1, global_scale = 0.01,
  slab_df = 4, slab_scale = 2.5)

laplace(location = 0, scale = NULL, autoscale = TRUE)

lasso(df = 1, location = 0, scale = NULL, autoscale = TRUE)

product_normal(df = 2, location = 0, scale = 1)

exponential(rate = 1, autoscale = TRUE)

decov(regularization = 1, concentration = 1, shape = 1, scale = 1)

lkj(regularization = 1, scale = 10, df = 1, autoscale = TRUE)

dirichlet(concentration = 1)

R2(location = NULL, what = c("mode", "mean", "median", "log"))
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>location</code></td>
<td>
<p>Prior location. In most cases, this is the prior mean, but
for <code>cauchy</code> (which is equivalent to <code>student_t</code> with
<code>df=1</code>), the mean does not exist and <code>location</code> is the prior
median. The default value is <i>0</i>, except for <code>R2</code> which has no
default value for <code>location</code>. For <code>R2</code>, <code>location</code> pertains
to the prior location of the <i>R^2</i> under a Beta distribution, but the
interpretation of the <code>location</code> parameter depends on the specified
value of the <code>what</code> argument (see the <em>R2 family</em> section in
<strong>Details</strong>).</p>
</td></tr>
<tr valign="top"><td><code>scale</code></td>
<td>
<p>Prior scale. The default depends on the family (see
<strong>Details</strong>).</p>
</td></tr>
<tr valign="top"><td><code>autoscale</code></td>
<td>
<p>A logical scalar, defaulting to <code>TRUE</code>. If <code>TRUE</code> 
then the scales of the priors on the intercept and regression coefficients 
may be additionally modified internally by <span class="pkg">rstanarm</span> in the following 
cases. First, for Gaussian models only, the prior scales for the intercept, 
coefficients, and the auxiliary parameter <code>sigma</code> (error standard 
deviation) are multiplied by <code>sd(y)</code>. Additionally &mdash; not only for 
Gaussian models &mdash; if the <code>QR</code> argument to the model fitting function
(e.g. <code>stan_glm</code>) is <code>FALSE</code> then: for a predictor with only one 
value nothing is changed; for a predictor <code>x</code> with exactly two unique 
values, we take the user-specified (or default) scale(s) for the selected 
priors and divide by the range of <code>x</code>; for a predictor <code>x</code> with 
more than two unique values, we divide the prior scale(s) by <code>sd(x)</code>.</p>
</td></tr>
<tr valign="top"><td><code>df, df1, df2</code></td>
<td>
<p>Prior degrees of freedom. The default is <i>1</i> for 
<code>student_t</code>, in which case it is equivalent to <code>cauchy</code>. For the 
hierarchical shrinkage priors (<code>hs</code> and <code>hs_plus</code>) the degrees of
freedom parameter(s) default to <i>3</i>. For the <code>product_normal</code> 
prior, the degrees of freedom parameter must be an integer (vector) that is
at least <i>2</i> (the default).</p>
</td></tr>
<tr valign="top"><td><code>global_df, global_scale, slab_df, slab_scale</code></td>
<td>
<p>Optional arguments for the
hierarchical shrinkage priors. See the <em>Hierarchical shrinkage family</em>
section below.</p>
</td></tr>
<tr valign="top"><td><code>rate</code></td>
<td>
<p>Prior rate for the exponential distribution. Defaults to
<code>1</code>. For the exponential distribution, the rate parameter is the
<em>reciprocal</em> of the mean.</p>
</td></tr>
<tr valign="top"><td><code>regularization</code></td>
<td>
<p>Exponent for an LKJ prior on the correlation matrix in
the <code>decov</code> or <code>lkj</code> prior. The default is <i>1</i>, implying a 
joint uniform prior.</p>
</td></tr>
<tr valign="top"><td><code>concentration</code></td>
<td>
<p>Concentration parameter for a symmetric Dirichlet 
distribution. The default is <i>1</i>, implying a joint uniform prior.</p>
</td></tr>
<tr valign="top"><td><code>shape</code></td>
<td>
<p>Shape parameter for a gamma prior on the scale parameter in the
<code>decov</code> prior. If <code>shape</code> and <code>scale</code> are both <i>1</i> (the
default) then the gamma prior simplifies to the unit-exponential
distribution.</p>
</td></tr>
<tr valign="top"><td><code>what</code></td>
<td>
<p>A character string among <code>'mode'</code> (the default),
<code>'mean'</code>, <code>'median'</code>, or <code>'log'</code> indicating how the
<code>location</code> parameter is interpreted in the <code>LKJ</code> case. If
<code>'log'</code>, then <code>location</code> is interpreted as the expected
logarithm of the <i>R^2</i> under a Beta distribution. Otherwise,
<code>location</code> is interpreted as the <code>what</code> of the <i>R^2</i>
under a Beta distribution. If the number of predictors is less than
or equal to two, the mode of this Beta distribution does not exist
and an error will prompt the user to specify another choice for
<code>what</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The details depend on the family of the prior being used:
</p>


<h4>Student t family</h4>

<p>Family members:
</p>

<ul>
<li> <p><code>normal(location, scale)</code>
</p>
</li>
<li> <p><code>student_t(df, location, scale)</code>
</p>
</li>
<li> <p><code>cauchy(location, scale)</code>
</p>
</li></ul>

<p>Each of these functions also takes an argument <code>autoscale</code>.
</p>
<p>For the prior distribution for the intercept, <code>location</code>, 
<code>scale</code>, and <code>df</code> should be scalars. For the prior for the other
coefficients they can either be vectors of length equal to the number of
coefficients (not including the intercept), or they can be scalars, in 
which case they will be recycled to the appropriate length. As the 
degrees of freedom approaches infinity, the Student t distribution 
approaches the normal distribution and if the degrees of freedom are one,
then the Student t distribution is the Cauchy distribution.
</p>
<p>If <code>scale</code> is not specified it will default to <i>10</i> for the
intercept and <i>2.5</i> for the other coefficients, unless the probit link
function is used, in which case these defaults are scaled by a factor of 
<code>dnorm(0)/dlogis(0)</code>, which is roughly <i>1.6</i>.
</p>
<p>If the <code>autoscale</code> argument is <code>TRUE</code> (the default), then the 
scales will be further adjusted as described above in the documentation of 
the <code>autoscale</code> argument in the <strong>Arguments</strong> section.
</p>



<h4>Hierarchical shrinkage family</h4>

<p>Family members:
</p>

<ul>
<li> <p><code>hs(df, global_df, global_scale, slab_df, slab_scale)</code>
</p>
</li>
<li> <p><code>hs_plus(df1, df2, global_df, global_scale, slab_df, slab_scale)</code>
</p>
</li></ul>

<p>The hierarchical shrinkage priors are normal with a mean of zero and a 
standard deviation that is also a random variable. The traditional 
hierarchical shrinkage prior utilizes a standard deviation that is 
distributed half Cauchy with a median of zero and a scale parameter that is
also half Cauchy. This is called the &quot;horseshoe prior&quot;. The hierarchical 
shrinkage (<code>hs</code>) prior in the <span class="pkg">rstanarm</span> package instead utilizes 
a regularized horseshoe prior, as described by Piironen and Vehtari (2017),
which recommends setting the <code>global_scale</code> argument equal to the ratio
of the expected number of non-zero coefficients to the expected number of
zero coefficients, divided by the square root of the number of observations.
</p>
<p>The hierarhical shrinkpage plus (<code>hs_plus</code>) prior is similar except 
that the standard deviation that is distributed as the product of two 
independent half Cauchy parameters that are each scaled in a similar way
to the <code>hs</code> prior.
</p>
<p>The hierarchical shrinkage priors have very tall modes and very fat tails.
Consequently, they tend to produce posterior distributions that are very
concentrated near zero, unless the predictor has a strong influence on the
outcome, in which case the prior has little influence. Hierarchical 
shrinkage priors often require you to increase the 
<code><a href="adapt_delta.html">adapt_delta</a></code> tuning parameter in order to diminish the number 
of divergent transitions. For more details on tuning parameters and 
divergent transitions see the Troubleshooting section of the <em>How to
Use the rstanarm Package</em> vignette.
</p>



<h4>Laplace family</h4>

<p>Family members:
</p>

<ul>
<li> <p><code>laplace(location, scale)</code>
</p>
</li>
<li> <p><code>lasso(df, location, scale)</code>
</p>
</li></ul>

<p>Each of these functions also takes an argument <code>autoscale</code>.
</p>
<p>The Laplace distribution is also known as the double-exponential 
distribution. It is a symmetric distribution with a sharp peak at its mean 
/ median / mode and fairly long tails. This distribution can be motivated 
as a scale mixture of normal distributions and the remarks above about the 
normal distribution apply here as well.
</p>
<p>The lasso approach to supervised learning can be expressed as finding the
posterior mode when the likelihood is Gaussian and the priors on the 
coefficients have independent Laplace distributions. It is commonplace in
supervised learning to choose the tuning parameter by cross-validation,
whereas a more Bayesian approach would be to place a prior on &ldquo;it&rdquo;,
or rather its reciprocal in our case (i.e. <em>smaller</em> values correspond
to more shrinkage toward the prior location vector). We use a chi-square
prior with degrees of freedom equal to that specified in the call to
<code>lasso</code> or, by default, 1. The expectation of a chi-square random
variable is equal to this degrees of freedom and the mode is equal to the
degrees of freedom minus 2, if this difference is positive.
</p>
<p>It is also common in supervised learning to standardize the predictors 
before training the model. We do not recommend doing so. Instead, it is
better to specify <code>autoscale = TRUE</code> (the default value), which 
will adjust the scales of the priors according to the dispersion in the
variables. See the documentation of the <code>autoscale</code> argument above 
and also the <code><a href="prior_summary.stanreg.html">prior_summary</a></code> page for more information.
</p>



<h4>Product-normal family</h4>

<p>Family members:
</p>

<ul>
<li> <p><code>product_normal(df, location, scale)</code>
</p>
</li></ul>

<p>The product-normal distribution is the product of at least two independent 
normal variates each with mean zero, shifted by the <code>location</code>
parameter. It can be shown that the density of a product-normal variate is
symmetric and infinite at <code>location</code>, so this prior resembles a
&ldquo;spike-and-slab&rdquo; prior for sufficiently large values of the
<code>scale</code> parameter. For better or for worse, this prior may be
appropriate when it is strongly believed (by someone) that a regression
coefficient &ldquo;is&rdquo; equal to the <code>location</code>, parameter even though
no true Bayesian would specify such a prior.
</p>
<p>Each element of <code>df</code> must be an integer of at least <i>2</i> because
these &ldquo;degrees of freedom&rdquo; are interpreted as the number of normal
variates being multiplied and then shifted by <code>location</code> to yield the
regression coefficient. Higher degrees of freedom produce a sharper
spike at <code>location</code>.
</p>
<p>Each element of <code>scale</code> must be a non-negative real number that is
interpreted as the standard deviation of the normal variates being
multiplied and then shifted by <code>location</code> to yield the regression
coefficient. In other words, the elements of <code>scale</code> may differ, but
the k-th standard deviation is presumed to hold for all the normal deviates
that are multiplied together and shifted by the k-th element of
<code>location</code> to yield the k-th regression coefficient. The elements of 
<code>scale</code> are not the prior standard deviations of the regression
coefficients. The prior variance of the regression coefficients is equal to
the scale raised to the power of <i>2</i> times the corresponding element of
<code>df</code>. Thus, larger values of <code>scale</code> put more prior volume on
values of the regression coefficient that are far from zero.
</p>



<h4>Dirichlet family</h4>

<p>Family members:
</p>

<ul>
<li> <p><code>dirichlet(concentration)</code>
</p>
</li></ul>

<p>The Dirichlet distribution is a multivariate generalization of the beta
distribution. It is perhaps the easiest prior distribution to specify
because the concentration parameters can be interpreted as prior counts
(although they need not be integers) of a multinomial random variable.
</p>
<p>The Dirichlet distribution is used in <code><a href="stan_polr.html">stan_polr</a></code> for an 
implicit prior on the cutpoints in an ordinal regression model. More
specifically, the Dirichlet prior pertains to the prior probability of
observing each category of the ordinal outcome when the predictors are at
their sample means. Given these prior probabilities, it is straightforward
to add them to form cumulative probabilities and then use an inverse CDF
transformation of the cumulative probabilities to define the cutpoints.
</p>
<p>If a scalar is passed to the <code>concentration</code> argument of the 
<code>dirichlet</code> function, then it is replicated to the appropriate length 
and the Dirichlet distribution is symmetric. If <code>concentration</code> is a
vector and all elements are <i>1</i>, then the Dirichlet distribution is
jointly uniform. If all concentration parameters are equal but greater than
<i>1</i> then the prior mode is that the categories are equiprobable, and
the larger the value of the identical concentration parameters, the more
sharply peaked the distribution is at the mode. The elements in 
<code>concentration</code> can also be given different values to represent that 
not all outcome categories are a priori equiprobable.
</p>



<h4>Covariance matrices</h4>

<p>Family members:
</p>

<ul>
<li> <p><code>decov(regularization, concentration, shape, scale)</code>
</p>
</li>
<li> <p><code>lkj(regularization, scale, df)</code>
</p>
</li></ul>

<p>(Also see vignette for <code>stan_glmer</code>)
</p>
<p>Covariance matrices are decomposed into correlation matrices and 
variances. The variances are in turn decomposed into the product of a
simplex vector and the trace of the matrix. Finally, the trace is the
product of the order of the matrix and the square of a scale parameter.
This prior on a covariance matrix is represented by the <code>decov</code> 
function.
</p>
<p>The prior for a correlation matrix is called LKJ whose density is 
proportional to the determinant of the correlation matrix raised to the 
power of a positive regularization parameter minus one. If
<code>regularization = 1</code> (the default), then this prior is jointly 
uniform over all correlation matrices of that size. If 
<code>regularization &gt; 1</code>, then the identity matrix is the mode and in the
unlikely case that <code>regularization &lt; 1</code>, the identity matrix is the
trough.
</p>
<p>The trace of a covariance matrix is equal to the sum of the variances. We
set the trace equal to the product of the order of the covariance matrix
and the <em>square</em> of a positive scale parameter. The particular
variances are set equal to the product of a simplex vector &mdash; which is
non-negative and sums to <i>1</i> &mdash; and the scalar trace. In other words,
each element of the simplex vector represents the proportion of the trace
attributable to the corresponding variable.
</p>
<p>A symmetric Dirichlet prior is used for the simplex vector, which has a 
single (positive) <code>concentration</code> parameter, which defaults to
<i>1</i> and implies that the prior is jointly uniform over the space of
simplex vectors of that size. If <code>concentration &gt; 1</code>, then the prior
mode corresponds to all variables having the same (proportion of total)
variance, which can be used to ensure the the posterior variances are not
zero. As the <code>concentration</code> parameter approaches infinity, this
mode becomes more pronounced. In the unlikely case that 
<code>concentration &lt; 1</code>, the variances are more polarized.
</p>
<p>If all the variables were multiplied by a number, the trace of their 
covariance matrix would increase by that number squared. Thus, it is 
reasonable to use a scale-invariant prior distribution for the positive
scale parameter, and in this case we utilize a Gamma distribution, whose
<code>shape</code> and <code>scale</code> are both <i>1</i> by default, implying a
unit-exponential distribution. Set the <code>shape</code> hyperparameter to some
value greater than <i>1</i> to ensure that the posterior trace is not zero.
</p>
<p>If <code>regularization</code>, <code>concentration</code>, <code>shape</code> and / or 
<code>scale</code> are positive scalars, then they are recycled to the 
appropriate length. Otherwise, each can be a positive vector of the 
appropriate length, but the appropriate length depends on the number of 
covariance matrices in the model and their sizes. A one-by-one covariance 
matrix is just a variance and thus does not have <code>regularization</code> or 
<code>concentration</code> parameters, but does have <code>shape</code> and 
<code>scale</code> parameters for the prior standard deviation of that 
variable.
</p>
<p>Note that for <code><a href="stan_mvmer.html">stan_mvmer</a></code> and <code><a href="stan_jm.html">stan_jm</a></code> models an
additional prior distribution is provided through the <code>lkj</code> function.
This prior is in fact currently used as the default for those modelling
functions (although <code>decov</code> is still available as an option if the user
wishes to specify it through the <code>prior_covariance</code> argument). The
<code>lkj</code> prior uses the same decomposition of the covariance matrices
into correlation matrices and variances, however, the variances are not
further decomposed into a simplex vector and the trace; instead the 
standard deviations (square root of the variances) for each of the group
specific parameters are given a half Student t distribution with the 
scale and df parameters specified through the <code>scale</code> and <code>df</code>
arguments to the <code>lkj</code> function. The scale parameter default is 10
which is then autoscaled, whilst the df parameter default is 1 
(therefore equivalent to a half Cauchy prior distribution for the 
standard deviation of each group specific parameter). This prior generally
leads to similar results as the <code>decov</code> prior, but it is also likely
to be **less** diffuse compared with the <code>decov</code> prior; therefore it 
sometimes seems to lead to faster estimation times, hence why it has
been chosen as the default prior for <code><a href="stan_mvmer.html">stan_mvmer</a></code> and 
<code><a href="stan_jm.html">stan_jm</a></code> where estimation times can be long.
</p>



<h4>R2 family</h4>

<p>Family members:
</p>

<ul>
<li> <p><code>R2(location, what)</code>
</p>
</li></ul>

<p>The <code><a href="stan_lm.html">stan_lm</a></code>, <code><a href="stan_lm.html">stan_aov</a></code>, and 
<code><a href="stan_polr.html">stan_polr</a></code> functions allow the user to utilize a function 
called <code>R2</code> to convey prior information about all the parameters. 
This prior hinges on prior beliefs about the location of <i>R^2</i>, the 
proportion of variance in the outcome attributable to the predictors, 
which has a <code><a href="../../stats/html/Beta.html">Beta</a></code> prior with first shape 
hyperparameter equal to half the number of predictors and second shape 
hyperparameter free. By specifying <code>what</code> to be the prior mode (the
default), mean, median, or expected log of <i>R^2</i>, the second shape
parameter for this Beta distribution is determined internally. If
<code>what = 'log'</code>, location should be a negative scalar; otherwise it
should be a scalar on the <i>(0,1)</i> interval.
</p>
<p>For example, if <i>R^2 = 0.5</i>, then the mode, mean, and median of
the <code><a href="../../stats/html/Beta.html">Beta</a></code> distribution are all the same and thus the
second shape parameter is also equal to half the number of predictors.
The second shape parameter of the <code><a href="../../stats/html/Beta.html">Beta</a></code> distribution
is actually the same as the shape parameter in the LKJ prior for a
correlation matrix described in the previous subsection. Thus, the smaller 
is <i>R^2</i>, the larger is the shape parameter, the smaller are the
prior correlations among the outcome and predictor variables, and the more
concentrated near zero is the prior density for the regression 
coefficients. Hence, the prior on the coefficients is regularizing and 
should yield a posterior distribution with good out-of-sample predictions 
<em>if</em> the prior location of <i>R^2</i> is specified in a reasonable 
fashion.
</p>



<h3>Value</h3>

<p>A named list to be used internally by the <span class="pkg">rstanarm</span> model
fitting functions.
</p>


<h3>References</h3>

<p>Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari,
A., and Rubin, D. B. (2013). <em>Bayesian Data Analysis.</em> Chapman &amp; Hall/CRC
Press, London, third edition. <a href="http://stat.columbia.edu/~gelman/book/">http://stat.columbia.edu/~gelman/book/</a>
</p>
<p>Gelman, A., Jakulin, A., Pittau, M. G., and Su, Y. (2008). A weakly
informative default prior distribution for logistic and other regression
models. <em>Annals of Applied Statistics</em>. 2(4), 1360&ndash;1383.
</p>
<p>Piironen, J., and Vehtari, A. (2017). Sparsity information and regularization
in the horseshoe and other shrinkage priors. <a href="https://arxiv.org/abs/1707.01694">https://arxiv.org/abs/1707.01694</a>
</p>
<p>Stan Development Team. (2017). <em>Stan Modeling Language Users Guide and
Reference Manual.</em> <a href="http://mc-stan.org/documentation/">http://mc-stan.org/documentation/</a>
</p>


<h3>See Also</h3>

<p>The various vignettes for the <span class="pkg">rstanarm</span> package also discuss 
and demonstrate the use of some of the supported prior distributions.
</p>


<h3>Examples</h3>

<pre>
fmla &lt;- mpg ~ wt + qsec + drat + am

# Draw from prior predictive distribution (by setting prior_PD = TRUE)
prior_pred_fit &lt;- stan_glm(fmla, data = mtcars, prior_PD = TRUE,
                           chains = 1, seed = 12345, iter = 250, # for speed only
                           prior = student_t(df = 4, 0, 2.5), 
                           prior_intercept = cauchy(0,10), 
                           prior_aux = exponential(1/2))
plot(prior_pred_fit, "hist")


# Can assign priors to names
N05 &lt;- normal(0, 5)
fit &lt;- stan_glm(fmla, data = mtcars, prior = N05, prior_intercept = N05)


# Visually compare normal, student_t, cauchy, laplace, and product_normal
compare_priors &lt;- function(scale = 1, df_t = 2, xlim = c(-10, 10)) {
  dt_loc_scale &lt;- function(x, df, location, scale) { 
    1/scale * dt((x - location)/scale, df)  
  }
  dlaplace &lt;- function(x, location, scale) {
    0.5 / scale * exp(-abs(x - location) / scale)
  }
  dproduct_normal &lt;- function(x, scale) {
    besselK(abs(x) / scale ^ 2, nu = 0) / (scale ^ 2 * pi)
  }
  stat_dist &lt;- function(dist, ...) {
    ggplot2::stat_function(ggplot2::aes_(color = dist), ...)
  }
  ggplot2::ggplot(data.frame(x = xlim), ggplot2::aes(x)) + 
    stat_dist("normal", size = .75, fun = dnorm, 
              args = list(mean = 0, sd = scale)) +
    stat_dist("student_t", size = .75, fun = dt_loc_scale, 
              args = list(df = df_t, location = 0, scale = scale)) +
    stat_dist("cauchy", size = .75, linetype = 2, fun = dcauchy, 
              args = list(location = 0, scale = scale)) + 
    stat_dist("laplace", size = .75, linetype = 2, fun = dlaplace,
              args = list(location = 0, scale = scale)) +
    stat_dist("product_normal", size = .75, linetype = 2, fun = dproduct_normal,
              args = list(scale = 1))            
}
# Cauchy has fattest tails, followed by student_t, laplace, and normal
compare_priors()

# The student_t with df = 1 is the same as the cauchy
compare_priors(df_t = 1) 

# Even a scale of 5 is somewhat large. It gives plausibility to rather 
# extreme values
compare_priors(scale = 5, xlim = c(-20,20)) 

# If you use a prior like normal(0, 1000) to be "non-informative" you are 
# actually saying that a coefficient value of e.g. -500 is quite plausible
compare_priors(scale = 1000, xlim = c(-1000,1000))

</pre>

<hr /><div style="text-align: center;">[Package <em>rstanarm</em> version 2.17.3 <a href="00Index.html">Index</a>]</div>
</body></html>
