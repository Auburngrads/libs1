<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Steady-state solver for ordinary differential equations;...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for steady.band {rootSolve}"><tr><td>steady.band {rootSolve}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>
Steady-state solver for ordinary differential equations; assumes a
banded jacobian
</h2>

<h3>Description</h3>

<p>Estimates the steady-state condition for a system of ordinary differential
equations.
</p>
<p>Assumes a banded jacobian matrix.
</p>


<h3>Usage</h3>

<pre>
steady.band(y, time = 0, func, parms = NULL, 
            nspec = NULL, bandup = nspec, banddown = nspec, 
            times = time, ...)</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>y </code></td>
<td>
<p>the initial guess of (state) values for the ODE system, a vector.
If <code>y</code> has a name attribute, the names will be used to label the
output matrix.
</p>
</td></tr>
<tr valign="top"><td><code>time, times </code></td>
<td>
<p>time for which steady-state is wanted; the default is
<code>times</code>=0.
(note- since version 1.7, 'times' has been added as an alias to 'time').
</p>
</td></tr>
<tr valign="top"><td><code>func </code></td>
<td>
<p>either an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function that computes the values of the
derivatives in the ode system (the model defininition) at time <code>time</code>,
or a character string giving the name of a compiled function in a
dynamically loaded shared library.
If <code>func</code>  is an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function, it must be defined as:
<code>yprime = func(t, y, parms,...)</code>.  <code>t</code> is the current time point
in the integration, <code>y</code> is the current estimate of the variables
in the ODE system.  If the initial values <code>y</code> has a names
attribute, the names will be available inside <code>func</code>. <code>parms</code> is
a vector or list of parameters; ... (optional) are any other arguments
passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first element is a
vector containing the derivatives of <code>y</code> with respect to
<code>time</code>, and whose next elements are global values whose steady-state
value is also required.
</p>
<p>The derivatives
should be specified in the same order as the state variables <code>y</code>.
</p>
</td></tr>
<tr valign="top"><td><code>parms </code></td>
<td>
<p>parameters passed to <code>func</code>.
</p>
</td></tr>
<tr valign="top"><td><code>nspec </code></td>
<td>
<p>the number of *species* (components) in the model.
</p>
</td></tr>
<tr valign="top"><td><code>bandup </code></td>
<td>
<p>the number of nonzero bands above the Jacobian diagonal.
</p>
</td></tr>
<tr valign="top"><td><code>banddown </code></td>
<td>
<p>the number of nonzero bands below the Jacobian diagonal.
</p>
</td></tr>
<tr valign="top"><td><code>... </code></td>
<td>
<p>additional arguments passed to function <code>stode</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the method of choice for single-species 1-D models.
</p>
<p>For multi-species 1-D models, this method can only be used if the state
variables are arranged per box, per species (e.g.
A[1],B[1],A[2],B[2],A[3],B[3],.... for species A, B).
</p>
<p>Usually a 1-D *model* function will have the species arranged as
A[1],A[2],A[3],....B[1],B[2],B[3],....
in this case, use <code>steady.1D</code>
</p>


<h3>Value</h3>

<p>A list containing 
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>y </code></td>
<td>
<p> a vector with the state variable values from the last iteration
during estimation of steady-state condition of the system of equations.
If <code>y</code> has a names attribute, it will be used to label the output
values.
</p>
</td></tr>
<tr valign="top"><td><code>... </code></td>
<td>
<p> the number of &quot;global&quot; values returned.
</p>
</td></tr>
</table>
<p>The output will have the attribute <code>steady</code>, which returns <code>TRUE</code>,
if steady-state has been reached and the attribute
<code>precis</code> with the precision attained during each iteration.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>See Also</h3>

<p><code><a href="steady.html">steady</a></code>, for a general interface to most of the steady-state
solvers
</p>
<p><code><a href="steady.1D.html">steady.1D</a></code>, <code><a href="steady.2D.html">steady.2D</a></code>,
<code><a href="steady.3D.html">steady.3D</a></code>, steady-state solvers for 1-D, 2-D and 3-D
partial differential equations.
</p>
<p><code><a href="stode.html">stode</a></code>, iterative steady-state solver for ODEs with full
or banded Jacobian.
</p>
<p><code><a href="stodes.html">stodes</a></code>, iterative steady-state solver for ODEs with arbitrary
sparse Jacobian.
</p>
<p><code><a href="runsteady.html">runsteady</a></code>, steady-state solver by dynamically running to
steady-state
</p>


<h3>Examples</h3>

<pre>
## =======================================================================
## 1000 simultaneous equations, solved 6 times for different 
## values of parameter "decay"
## =======================================================================

model &lt;- function (time, OC, parms, decay)  {
  # model of particles (OC) that sink out of the water and decay
  # exponentially declining sinking rate, maximal 100 m/day
  sink &lt;- 100 * exp(-0.01*dist)
  
  # boundary flux; upper boundary=imposed concentration (100)
  Flux &lt;- sink * c(100 ,OC)     
   
  # Rate of change= Flux gradient and first-order consumption
  dOC  &lt;- -diff(Flux)/dx - decay*OC
  list(dOC, maxC = max(OC))
}

dx   &lt;- 1                          # thickness of boxes
dist &lt;- seq(0, 1000, by = dx)      # water depth at each modeled box interface

ss   &lt;- NULL 
for (decay in seq(from = 0.1, to = 1.1, by = 0.2))
  ss   &lt;- cbind(ss, steady.band(runif(1000), func = model,
                parms = NULL, nspec = 1, decay = decay)$y)  

matplot(ss, 1:1000, type = "l", lwd = 2, main = "steady.band", 
  ylim=c(1000, 0), ylab = "water depth, m", 
  xlab = "concentration of sinking particles")

legend("bottomright", legend = seq(from = 0.1, to = 1.1, by = 0.2),
   lty = 1:10, title = "decay rate", col = 1:10, lwd = 2)

## =======================================================================
## 5001 simultaneous equations: solve
## dy/dt = 0 = d2y/dx2 + 1/x*dy/dx + (1-1/(4x^2)y - sqrx(x)*cos(x),
## over the interval [1,6], with boundary conditions: y(1)=1, y(6)=-0.5
## =======================================================================

derivs &lt;- function(t, y, parms, x, dx, N, y1, y6)  {

  # Numerical approximation of derivates:
  # d2y/dx2 = (yi+1-2yi+yi-1)/dx^2
   d2y &lt;- (c(y[-1],y6) -2*y + c(y1,y[-N])) /dx/dx

  # dy/dx = (yi+1-yi-1)/(2dx)
   dy  &lt;- (c(y[-1],y6) - c(y1,y[-N])) /2/dx

   res &lt;- d2y+dy/x+(1-1/(4*x*x))*y-sqrt(x)*cos(x)
   return(list(res))
}

dx     &lt;- 0.001
x      &lt;- seq(1,6,by=dx)
N      &lt;- length(x)
y  &lt;- steady.band(y = rep(1, N), time = 0, func = derivs, x = x, dx = dx,
                  N = N, y1 = 1, y6 = -0.5, nspec = 1)$y
plot(x, y, type = "l", main = "5001 nonlinear equations - banded Jacobian")

# add the analytic solution for comparison:
xx     &lt;- seq(1, 6, by = 0.1)
ana &lt;- 0.0588713*cos(xx)/sqrt(xx)+1/4*sqrt(xx)*cos(xx)+
       0.740071*sin(xx)/sqrt(xx)+1/4*xx^(3/2)*sin(xx)
points(xx, ana)
legend("topright", pch = c(NA, 1), lty = c(1, NA),
       c("numeric", "analytic"))

</pre>

<hr /><div style="text-align: center;">[Package <em>rootSolve</em> version 1.8.1 <a href="00Index.html">Index</a>]</div>
</body></html>
