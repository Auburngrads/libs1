<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Dynamically runs a system of ordinary differential equations...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for runsteady {rootSolve}"><tr><td>runsteady {rootSolve}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>
Dynamically runs a system of ordinary differential equations (ODE) to
steady-state
</h2>

<h3>Description</h3>

<p>Solves the steady-state condition of ordinary differential equations (ODE)
in the form:
</p>
<p style="text-align: center;"><i>dy/dt = f(t,y)</i></p>
  
<p>by dynamically running till the summed absolute values of the derivatives
become smaller than some predefined tolerance.
</p>
<p>The <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>runsteady</code> makes use of the FORTRAN ODE solver DLSODE,
written by Alan C. Hindmarsh and Andrew H. Sherman
</p>
<p>The system of ODE's is written as an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function or defined in
compiled code that has been dynamically loaded. The user has to specify
whether or not the problem is stiff and choose the appropriate solution
method (e.g. make choices about the type of the Jacobian).
</p>


<h3>Usage</h3>

<pre>
runsteady(y, time = c(0, Inf), func, parms, 
          stol = 1e-8, rtol = 1e-6, atol = 1e-6,  
          jacfunc = NULL, jactype = "fullint", mf = NULL, 
          verbose = FALSE, tcrit = NULL, hmin = 0, hmax = NULL, 
          hini = 0, ynames = TRUE, maxord = NULL, bandup = NULL, 
          banddown = NULL, maxsteps = 100000, dllname = NULL, 
          initfunc = dllname, initpar = parms, rpar = NULL, 
          ipar = NULL, nout = 0, outnames = NULL, 
          forcings = NULL, initforc = NULL, fcontrol = NULL, 
          lrw = NULL, liw = NULL, times = time, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>y </code></td>
<td>
<p>the initial (state) values for the ODE system. If <code>y</code> has a
name attribute, the names will be used to label the output matrix.
</p>
</td></tr>
<tr valign="top"><td><code>time, times </code></td>
<td>
<p>The simulation time. This should be a 2-valued vector,
consisting of the initial time and the end time.
The last time value should be large enough to make sure that steady-state
is effectively reached in this period.
The simulation will stop either when <code>times[2]</code> has been reached or
when <code>maxsteps</code> have been performed.
(note: since version 1.7, argument time has been added, for consistency with other solvers.)
</p>
</td></tr>
<tr valign="top"><td><code>func </code></td>
<td>
<p>either an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the <em>model definition</em>) at time
t, or a character string giving the name of a compiled function
in a dynamically loaded shared library.
</p>
<p>If <code>func</code>  is an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function, it must be defined as:
<code>yprime = func(t, y, parms,...)</code>.  <code>t</code> is the current time point
in the integration, <code>y</code> is the current estimate of the variables
in the ODE system.  If the initial values <code>y</code> has a names
attribute, the names will be available inside <code>func</code>.  <code>parms</code> is
a vector or list of parameters; ... (optional) are any other arguments
passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first element is a
vector containing the derivatives of <code>y</code> with respect to
<code>time</code>, and whose next elements are global values that are required at
each point in <code>times</code>.
</p>
<p>The derivatives
should be specified in the same order as the state variables <code>y</code>.
</p>
</td></tr>
<tr valign="top"><td><code>parms </code></td>
<td>
<p>vector or list of parameters used in <code>func</code> or
<code>jacfunc</code>.
</p>
</td></tr>
<tr valign="top"><td><code>stol </code></td>
<td>
<p>steady-state tolerance; it is assumed that steady-state is
reached if the average of absolute values of the derivatives
drops below this number.
</p>
</td></tr>
<tr valign="top"><td><code>rtol </code></td>
<td>
<p>relative error tolerance of integrator, either a scalar or an
array as long as <code>y</code>.  See details.
</p>
</td></tr>
<tr valign="top"><td><code>atol </code></td>
<td>
<p>absolute error tolerance of integrator, either a scalar or an
array as long as <code>y</code>.  See details.
</p>
</td></tr>
<tr valign="top"><td><code>jacfunc </code></td>
<td>
<p>if not <code>NULL</code>, an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function that computes
the jacobian of the system of differential equations
dydot(i)/dy(j), or a string giving the name of a function or
subroutine in &lsquo;<span class="file">dllname</span>&rsquo; that computes the jacobian (see Details
below for more about this option).  In some circumstances, supplying
<code>jacfunc</code> can speed up the computations, if the system is stiff.
The <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> calling sequence for <code>jacfunc</code> is identical
to that of <code>func</code>.
</p>
<p>If the jacobian is a full matrix, <code>jacfunc</code> should return a matrix
dydot/dy, where the ith row contains the derivative of <i>dy_i/dt</i> with
respect to <i>y_j</i>, or a vector containing the matrix elements by
columns (the way <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> and Fortran store matrices).
</p>
<p>If the jacobian is banded, <code>jacfunc</code> should return a matrix containing
only the nonzero bands of the jacobian, rotated row-wise. See first example
of <code>lsode</code>.
</p>
</td></tr>
<tr valign="top"><td><code>jactype </code></td>
<td>
<p>the structure of the jacobian, 
one of &quot;fullint&quot;, &quot;fullusr&quot;, &quot;bandusr&quot;, &quot;bandint&quot;, &quot;sparse&quot; - either full,
banded or sparse and estimated internally or by user; overruled if <code>mf</code>
is not NULL.   If &quot;sparse&quot; then method lsodes is used, else lsode.
</p>
</td></tr>
<tr valign="top"><td><code>mf </code></td>
<td>
<p>the &quot;method flag&quot; passed to function lsode - overrules
<code>jactype</code> - provides more options than <code>jactype</code> - see details.
</p>
</td></tr>
<tr valign="top"><td><code>verbose </code></td>
<td>
<p>if <code>TRUE</code>: full output to the screen, e.g. will output
the settings of vectors *istate* and *rstate* - see details.
</p>
</td></tr>
<tr valign="top"><td><code>tcrit </code></td>
<td>
<p>if not <code>NULL</code>, then <code>lsode</code> cannot integrate past
<code>tcrit</code>. The Fortran routine <code>lsode</code> overshoots its targets
(times points in the vector <code>times</code>), and interpolates values
for the desired time points.  If there is a time beyond which integration
should not proceed (perhaps because of a singularity),
that should be provided in <code>tcrit</code>.
</p>
</td></tr>
<tr valign="top"><td><code>hmin </code></td>
<td>
<p>an optional minimum value of the integration
stepsize. In special situations this parameter may speed up computations
with the cost of precision. Don't use <code>hmin</code> if you don't know why!
</p>
</td></tr>
<tr valign="top"><td><code>hmax </code></td>
<td>
<p>an optional maximum value of the integration stepsize. If not
specified, <code>hmax</code> is set to the largest difference in <code>times</code>,
to avoid that the simulation possibly ignores short-term events. If 0,
no maximal size is specified.
</p>
</td></tr>
<tr valign="top"><td><code>hini </code></td>
<td>
<p>initial step size to be attempted; if 0, the initial step size
is determined by the solver.
</p>
</td></tr>
<tr valign="top"><td><code>ynames </code></td>
<td>
<p>if <code>FALSE</code>: names of state variables are not passed to
function <code>func</code> ; this may speed up the simulation.
</p>
</td></tr>
<tr valign="top"><td><code>maxord </code></td>
<td>
<p>the maximum order to be allowed. <code>NULL</code> uses the default,
i.e. order 12 if implicit Adams method (meth=1), order 5 if BDF method
(meth=2) or if <code>jacType</code> == 'sparse'. Reduce maxord to save storage space.
</p>
</td></tr>
<tr valign="top"><td><code>bandup </code></td>
<td>
<p>number of non-zero bands above the diagonal, in case the
jacobian is banded.
</p>
</td></tr>
<tr valign="top"><td><code>banddown </code></td>
<td>
<p>number of non-zero bands below the diagonal, in case the
jacobian is banded.
</p>
</td></tr>
<tr valign="top"><td><code>maxsteps </code></td>
<td>
<p>maximal number of steps. The simulation will stop either
when <code>maxsteps</code> have been performed or when <code>times[2]</code> has been
reached.
</p>
</td></tr>
<tr valign="top"><td><code>dllname </code></td>
<td>
<p>a string giving the name of the shared library (without
extension) that contains all the compiled function or subroutine
definitions refered to in <code>func</code> and <code>jacfunc</code>. See package
vignette.
</p>
</td></tr>
<tr valign="top"><td><code>initfunc </code></td>
<td>
<p>if not NULL, the name of the initialisation function (which
initialises values of parameters), as provided in &lsquo;<span class="file">dllname</span>&rsquo;. See
package vignette.
</p>
</td></tr>
<tr valign="top"><td><code>initpar </code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified and an initialisation
function <code>initfunc</code> is in the dll: the parameters passed to the
initialiser, to initialise the common blocks (fortran) or global variables
(C, C++).
</p>
</td></tr>
<tr valign="top"><td><code>rpar </code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with double
precision values passed to the dll-functions whose names are specified
by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr valign="top"><td><code>ipar </code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with integer
values passed to the dll-functions whose names are specified by <code>func</code>
and <code>jacfunc</code>.
</p>
</td></tr>
<tr valign="top"><td><code>nout </code></td>
<td>
<p>only used if <code>dllname</code> is specified and the model is
defined in compiled code: the number of output variables calculated in
the compiled function <code>func</code>, present in the shared library. Note:
it is not automatically checked whether this is indeed the number of output
variables calculed in the dll - you have to perform this check in the code
- See package vignette of deSolve.
</p>
</td></tr>
<tr valign="top"><td><code>outnames </code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>func</code>, present in the shared library.
</p>
</td></tr>
<tr valign="top"><td><code>forcings </code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with the 
forcing function values, or a list with the forcing function data sets, 
each present as a two-columned matrix, with (time,value); interpolation 
outside the interval [min(<code>times</code>), max(<code>times</code>)] is done by 
taking the value at the closest data extreme.
</p>
<p>This feature is here for compatibility with models defined in compiled code
from package deSolve; see deSolve's package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>initforc </code></td>
<td>
<p>if not <code>NULL</code>, the name of the forcing function
initialisation function, as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. It MUST be present if <code>forcings</code> has been given a
value.
See deSolve's package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>fcontrol </code></td>
<td>
<p>A list of control parameters for the forcing functions.
See deSolve's package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>lrw </code></td>
<td>
<p>Only if jactype = 'sparse', the length of the real work array rwork; due to the
sparsicity, this cannot be readily predicted. If <code>NULL</code>, a
guess will be made, and if not sufficient, <code>lsodes</code> will return
with a message indicating the size of rwork actually required.
Therefore, some experimentation may be necessary to estimate the
value of <code>lrw</code>.
</p>
<p>For instance, if you get the error:
</p>
<pre> 
DLSODES- RWORK length is insufficient to proceed.                               
  Length needed is .ge. LENRW (=I1), exceeds LRW (=I2)                    
  In above message,  I1 =     27627   I2 =     25932 
</pre>    
<p>set <code>lrw</code> equal to 27627 or a higher value
</p>
</td></tr>
<tr valign="top"><td><code>liw </code></td>
<td>
<p>Only if jactype = 'sparse', the length of the integer work array iwork; due to the
sparsicity, this cannot be readily predicted. If <code>NULL</code>, a guess will
be made, and if not sufficient, <code>lsodes</code> will return with a
message indicating the size of iwork actually required.  Therefore,
some experimentation may be necessary to estimate the value of
<code>liw</code>.
</p>
</td></tr>
<tr valign="top"><td><code>... </code></td>
<td>
<p>additional arguments passed to <code>func</code> and <code>jacfunc</code>
allowing this to be a generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The work is done by the Fortran subroutine <code>dlsode</code> or <code>dlsodes</code> (if sparse),
whose documentation should be consulted for details (it is included as
comments in the source file &lsquo;<span class="file">src/lsodes.f</span>&rsquo;).  The implementation is
based on the November, 2003 version of lsode, from Netlib.
</p>
<p>Before using <code>runsteady</code>, the user has to decide whether or not the
problem is stiff. 
</p>
<p>If the problem is nonstiff, use method flag <code>mf</code> = 10, which selects
a nonstiff (Adams) method, no Jacobian used..  
</p>
<p>If the problem is stiff, there are four standard choices
which can be specified with <code>jactype</code> or <code>mf</code>.
</p>
<p>The options for <b>jactype</b> are
</p>

<ul>
<li><p> jactype = &quot;fullint&quot; : a full jacobian, calculated internally by
<code>lsode</code>, corresponds to <code>mf</code>=22.
</p>
</li>
<li><p> jactype = &quot;fullusr&quot; : a full jacobian, specified by user function
<code>jacfunc</code>, corresponds to <code>mf</code>=21.
</p>
</li>
<li><p> jactype = &quot;bandusr&quot; : a banded jacobian, specified by user function
<code>jacfunc</code>; the size of the bands specified by <code>bandup</code> and
<code>banddown</code>, corresponds to <code>mf</code>=24.
</p>
</li>
<li><p> jactype = &quot;bandint&quot; : a banded jacobian, calculated by <code>lsode</code>;
the size of the bands specified by <code>bandup</code> and <code>banddown</code>,
corresponds to <code>mf</code>=25.
</p>
</li>
<li><p> jactype = &quot;sparse&quot; : the soler <code>lsodes</code> is used, and the sparse jacobian is 
calculated by <code>lsodes</code> - not possible to specify <code>jacfunc</code>.
</p>
</li></ul>

<p>More options are available when specifying <b>mf</b> directly. 
</p>
<p>The legal values of <code>mf</code> are 10, 11, 12, 13, 14, 15, 20, 21, 22, 23,
24, 25.
</p>
<p><code>mf</code> is a positive two-digit integer, <code>mf</code> = (10*METH + MITER),
where
</p>

<ul>
<li><p> METH indicates the basic linear multistep method: METH = 1 means
the implicit Adams method. METH = 2 means the method based on backward
differentiation formulas (BDF-s).
</p>
</li>
<li><p> MITER indicates the corrector iteration method: MITER = 0 means
functional iteration (no Jacobian matrix is involved).
MITER = 1 means chord iteration with a user-supplied full (NEQ by NEQ)
Jacobian.
MITER = 2 means chord iteration with an internally generated
(difference quotient) full Jacobian
(using NEQ extra calls to <code>func</code> per df/dy value).
MITER = 3 means chord iteration with an internally generated diagonal
Jacobian approximation
(using 1 extra call to <code>func</code> per df/dy evaluation).
MITER = 4 means chord iteration with a user-supplied banded Jacobian.
MITER = 5 means chord iteration with an internally generated banded
Jacobian (using ML+MU+1 extra calls to <code>func</code> per df/dy evaluation).
</p>
<p>If MITER = 1 or 4, the user must supply a subroutine <code>jacfunc</code>.
</p>
</li></ul>

<p>Inspection of the example below shows how to specify both a banded and full
jacobian. 
</p>
<p>The input parameters <code>rtol</code>, and <code>atol</code> determine the <b>error
control</b> performed by the solver. 
</p>
<p>See <code><a href="stode.html">stode</a></code> for details.
</p>
<p><b>Models</b> may be defined in compiled C or Fortran code, as well as in
an R-function. See function <code><a href="stode.html">stode</a></code> for details.
</p>
<p>The output will have the <b>attributes *istate*, and *rstate*</b>, two
vectors with several useful elements. 
</p>
<p>if <code>verbose</code> = TRUE, the settings of istate and rstate will be written
to the screen.
</p>
<p>the following elements of <b>istate</b> are meaningful:
</p>

<ul>
<li><p> el 1 : gives the conditions under which the last call to the
integrator returned.
2  if lsode was successful, -1 if excess work done, -2 means excess
accuracy requested. (Tolerances too small),
-3 means illegal input detected. (See printed message.),
-4 means repeated error test failures. (Check all input),
-5 means repeated convergence failures. (Perhaps bad Jacobian
supplied or wrong choice of MF or tolerances.),
-6 means error weight became zero during problem. (Solution
component i vanished, and atol or atol(i) = 0.)
</p>
</li>
<li><p> el 12 : The number of steps taken for the problem so far.
</p>
</li>
<li><p> el 13 : The number of evaluations for the problem so far.,
</p>
</li>
<li><p> el 14 : The number of Jacobian evaluations  and LU decompositions
so far.,
</p>
</li>
<li><p> el 15 : The method order last used (successfully).,
</p>
</li>
<li><p> el 16 : The order to be attempted on the next step.,
</p>
</li>
<li><p> el 17 : if el 1 =-4,-5: the largest component in the error vector,
</p>
</li></ul>

<p><b>rstate</b> contains the following:
</p>

<ul>
<li><p> 1: The step size in t last used (successfully).
</p>
</li>
<li><p> 2: The step size to be attempted on the next step.
</p>
</li>
<li><p> 3: The current value of the independent variable which the solver
has actually reached, i.e. the current internal mesh point in t.
</p>
</li>
<li><p> 4: A tolerance scale factor, greater than 1.0, computed when a
request for too much accuracy was detected.
</p>
</li></ul>

<p>For more information, see the comments in the original code lsode.f</p>


<h3>Value</h3>

<p>A list containing 
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>y </code></td>
<td>
<p> a vector with the state variable values from the last iteration
during estimation of steady-state condition of the system of equations.
If <code>y</code> has a names attribute, it will be used to label the output
values.
</p>
</td></tr>
<tr valign="top"><td><code>... </code></td>
<td>
<p> the number of &quot;global&quot; values returned.
</p>
</td></tr>
</table>
<p>The output will have the attribute <code>steady</code>, which returns <code>TRUE</code>,
if steady-state has been reached, the attribute <code>precis</code> with the
precision attained at the last iteration estimated as the mean absolute
rate of change (sum(abs(dy))/n), the attribute <code>time</code> with the
simulation time reached and the attribute <code>steps</code> with the number of
steps performed.
</p>
<p>The output will also have the attributes <code>istate</code>, and <code>rstate</code>,
two vectors with several useful elements of the dynamic simulation.
See details.
The first element of istate returns the conditions under which the last call
to the integrator returned. Normal is <code>istate[1] = 2</code>.
If <code>verbose</code> = <code>TRUE</code>, the settings of istate and rstate will
be written to the screen.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>References</h3>

<p> Alan C. Hindmarsh, &quot;ODEPACK, A Systematized Collection of ODE
Solvers,&quot; in Scientific Computing, R. S. Stepleman, et al., Eds.
(North-Holland, Amsterdam, 1983), pp. 55-64.
</p>
<p>S. C. Eisenstat, M. C. Gursky, M. H. Schultz, and A. H. Sherman, Yale
Sparse Matrix Package: I. The Symmetric Codes,
Int. J. Num. Meth. Eng., 18 (1982), pp. 1145-1151.
</p>
<p>S. C. Eisenstat, M. C. Gursky, M. H. Schultz, and A. H. Sherman, Yale
Sparse Matrix Package: II. The Nonsymmetric Codes, Research Report
No. 114, Dept. of Computer Sciences, Yale University, 1977.
</p>


<h3>See Also</h3>

<p><code><a href="steady.html">steady</a></code>, for a general interface to most of the steady-state
solvers
</p>
<p><code><a href="steady.band.html">steady.band</a></code>, to find the steady-state of ODE models with a
banded Jacobian
</p>
<p><code><a href="steady.1D.html">steady.1D</a></code>, <code><a href="steady.2D.html">steady.2D</a></code>,
<code><a href="steady.3D.html">steady.3D</a></code> steady-state solvers for 1-D, 2-D and 3-D
partial differential equations.
</p>
<p><code><a href="stode.html">stode</a></code>, iterative steady-state solver for ODEs with full
or banded Jacobian.
</p>
<p><code><a href="stodes.html">stodes</a></code>, iterative steady-state solver for ODEs with arbitrary
sparse Jacobian.
</p>


<h3>Examples</h3>

<pre>
## =======================================================================
## A simple sediment biogeochemical model
## =======================================================================

model&lt;-function(t, y, pars) {

with (as.list(c(y, pars)),{

  Min       = r*OM
  oxicmin   = Min*(O2/(O2+ks))
  anoxicmin = Min*(1-O2/(O2+ks))* SO4/(SO4+ks2)

  dOM  = Flux - oxicmin - anoxicmin
  dO2  = -oxicmin      -2*rox*HS*(O2/(O2+ks)) + D*(BO2-O2)
  dSO4 = -0.5*anoxicmin  +rox*HS*(O2/(O2+ks)) + D*(BSO4-SO4)
  dHS  = 0.5*anoxicmin   -rox*HS*(O2/(O2+ks)) + D*(BHS-HS)

  list(c(dOM, dO2, dSO4, dHS), SumS = SO4+HS)
})
}

# parameter values
pars &lt;- c(D = 1, Flux = 100, r = 0.1, rox = 1,
          ks = 1, ks2 = 1, BO2 = 100, BSO4 = 10000, BHS = 0)
# initial conditions
y &lt;- c(OM = 1, O2 = 1, SO4 = 1, HS = 1)

# direct iteration
print( system.time(
  ST &lt;- stode(y = y, func = model, parms = pars, pos = TRUE)
))

print( system.time(
  ST2 &lt;- runsteady(y = y, func = model, parms = pars, times = c(0, 1000))
))

print( system.time(
  ST3 &lt;- runsteady(y = y, func = model, parms = pars, times = c(0, 1000), 
    jactype = "sparse")
))

rbind("Newton Raphson" = ST$y, "Runsteady" = ST2$y, "Run sparse" = ST3$y)
</pre>

<hr /><div style="text-align: center;">[Package <em>rootSolve</em> version 1.8.1 <a href="00Index.html">Index</a>]</div>
</body></html>
