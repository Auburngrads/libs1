<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Steady-state solver for multicomponent 1-D ordinary...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for steady.1D {rootSolve}"><tr><td>steady.1D {rootSolve}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>
Steady-state solver for multicomponent 1-D ordinary differential equations
</h2>

<h3>Description</h3>

<p>Estimates the steady-state condition for a system of ordinary differential
equations that result from 1-Dimensional partial differential equation
models that have been converted to ODEs by numerical differencing.
</p>
<p>It is assumed that exchange occurs only between adjacent layers.</p>


<h3>Usage</h3>

<pre>
steady.1D(y, time = NULL, func, parms = NULL, 
          nspec = NULL, dimens = NULL, 
          names = NULL, method = "stode", jactype = NULL, 
          cyclicBnd = NULL, bandwidth = 1, times = time, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>y </code></td>
<td>
<p>the initial guess of (state) values for the ODE system, a vector.
</p>
</td></tr>
<tr valign="top"><td><code>time, times </code></td>
<td>
<p>time for which steady-state is wanted; 
the default is <code>times=0</code> (for <code>method = "stode"</code> or 
<code>method = "stodes"</code>, and <code>times = c(0,Inf)</code> for 
<code>method = "runsteady"</code> ).
(note- since version 1.7, 'times' has been added as an alias to 'time').
</p>
</td></tr>
<tr valign="top"><td><code>func </code></td>
<td>
<p>either an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function that computes the values of the
derivatives in the ode system (the model defininition) at time <code>time</code>,
or a character string giving the name of a compiled function in a
dynamically loaded shared library.
</p>
<p>If <code>func</code>  is an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function, it must be defined as:
<code>yprime = func(t, y, parms,...)</code>.  <code>t</code> is the current time point
in the integration, <code>y</code> is the current estimate of the variables
in the ODE system.  If the initial values <code>y</code> has a names
attribute, the names will be available inside <code>func</code>. <code>parms</code> is
a vector or list of parameters; ... (optional) are any other arguments
passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first element is a
vector containing the derivatives of <code>y</code> with respect to
<code>time</code>, and whose next elements are global values whose steady-state
value is also required.
</p>
<p>The derivatives
should be specified in the same order as the state variables <code>y</code>.
</p>
</td></tr>
<tr valign="top"><td><code>parms </code></td>
<td>
<p>parameters passed to <code>func</code>.
</p>
</td></tr>
<tr valign="top"><td><code>nspec </code></td>
<td>
<p>the number of *species* (components) in the model.
If <code>NULL</code>, then <code>dimens</code> should be specified.
</p>
</td></tr>
<tr valign="top"><td><code>dimens</code></td>
<td>
<p>the number of *boxes* in the model. If NULL, then
<code>nspec</code> should be specified.
</p>
</td></tr>
<tr valign="top"><td><code>names </code></td>
<td>
<p>the names of the components; used to label the output, which
will be written as a matrix.
</p>
</td></tr>
<tr valign="top"><td><code>method </code></td>
<td>
<p>the solution method, one of &quot;stode&quot;, &quot;stodes&quot;, or &quot;runsteady&quot;.
When <code>method</code> = 'runsteady', then solver <code>lsode</code> is used by default, 
unless argument <code>jactype</code> is set to <code>"sparse"</code>, 
in which case <code>lsodes</code> is used and the structure of the jacobian is determined by the solver.
</p>
</td></tr>
<tr valign="top"><td><code>jactype </code></td>
<td>
<p>the jacobian type - default is a regular 1-D structure where layers only interact with adjacent layers. 
If the structure does not comply with this, the jacobian can be set equal to <code>'sparse'</code> if <code>method = stodes</code>.
If <code>jactype = 'sparse'</code> and <code>method = runsteady</code> then <code>lsodes</code>, the sparse integrator, will be used.
</p>
</td></tr>
<tr valign="top"><td><code>cyclicBnd </code></td>
<td>
<p>if a cyclic boundary exists, a value of <code>1</code> else
<code>NULL</code>; see details.
</p>
</td></tr>
<tr valign="top"><td><code>bandwidth </code></td>
<td>
<p>the number of adjacent boxes over which transport occurs.
Normally equal to 1 (box i only interacts with box i-1, and i+1). 
Values larger than 1 will not work with <code>method = "stodes"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>... </code></td>
<td>
<p>additional arguments passed to the solver function as defined
by <code>method</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the method of choice for multi-species 1-dimensional models, that
are only subjected to transport between adjacent layers
</p>
<p>More specifically, this method is to be used if the state variables are
arranged per species:
</p>
<p>A[1],A[2],A[3],....B[1],B[2],B[3],.... (for species A, B))
</p>
<p>Two methods are implemented.
</p>

<ul>
<li><p> The default method rearranges the state variables as
A[1],B[1],...A[2],B[2],...A[3],B[3],.... This reformulation leads to
a banded Jacobian with (upper and lower) half bandwidth = number of species.
Then function <code>stode</code> solves the banded problem.
</p>
</li>
<li><p> The second method uses function <code>stodes</code>. Based on the
dimension of the problem, the method first calculates the sparsity pattern
of the Jacobian, under the assumption that transport is only occurring
between adjacent layers. Then <code>stodes</code> is called to solve the problem.
</p>
<p>As <code>stodes</code> is used to estimate steady-state, it may be necessary to
specify the length of the real work array, <code>lrw</code>.
</p>
<p>Although a reasonable guess of <code>lrw</code> is made, it is possible that
this will be too low.
In this case, <code>steady.1D</code> will return with an error message telling
the size of the work array actually needed. In the second try then,
set <code>lrw</code> equal to this number.
</p>
</li></ul>

<p>For single-species 1-D models, use <code><a href="steady.band.html">steady.band</a></code>. 
</p>
<p>If state variables are arranged as (e.g. A[1],B[1],A[2],B[2],A[3],B[3],...
then the model should be solved with  <code><a href="steady.band.html">steady.band</a></code>
</p>
<p>In some cases, a cyclic boundary condition exists. This is when the first
box interacts with the last box and vice versa. In this case, there
will be extra non-zero fringes in the Jacobian which need to be taken
into account. The occurrence of cyclic boundaries can be
toggled on by specifying argument <code>cyclicBnd=1</code>. If this is the
case, then the steady-state will be estimated using <code>stodes</code>.
The default is no cyclic boundaries.
</p>


<h3>Value</h3>

<p>A list containing 
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>y </code></td>
<td>
<p> if <code>names</code> is not given: a vector with the state variable
values from the last iteration during estimation of steady-state condition
of the system of equations.
if <code>names</code> is given, a matrix with one column for every steady-state
*component*.
</p>
</td></tr>
<tr valign="top"><td><code>... </code></td>
<td>
<p> the number of &quot;global&quot; values returned.
</p>
</td></tr>
</table>
<p>The output will have the attribute <code>steady</code>, which returns TRUE, if
steady-state has been reached and the attribute
<code>precis</code> with the precision attained during each iteration.
</p>


<h3>Note</h3>

<p>It is advisable though not mandatory to specify BOTH <code>nspec</code> and
<code>dimens</code>.
In this case, the solver can check whether the input makes sense
(i.e. if  nspec*dimens = length(y))
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>See Also</h3>

<p><code><a href="plot.steady.html">plot.steady1D</a></code> for plotting the output of steady.1D
</p>
<p><code><a href="steady.html">steady</a></code>, for a general interface to most of the steady-state
solvers
</p>
<p><code><a href="steady.band.html">steady.band</a></code>, to find the steady-state of ODE models with a
banded Jacobian
</p>
<p><code><a href="steady.2D.html">steady.2D</a></code>,
<code><a href="steady.3D.html">steady.3D</a></code>, steady-state solvers for 2-D and 3-D
partial differential equations.
</p>
<p><code><a href="stode.html">stode</a></code>, iterative steady-state solver for ODEs with full
or banded Jacobian.
</p>
<p><code><a href="stodes.html">stodes</a></code>, iterative steady-state solver for ODEs with arbitrary
sparse Jacobian.
</p>
<p><code><a href="runsteady.html">runsteady</a></code>, steady-state solver by dynamically running to
steady-state
</p>


<h3>Examples</h3>

<pre>
## =======================================================================
##  EXAMPLE 1: BOD + O2                                
## =======================================================================
## Biochemical Oxygen Demand (BOD) and oxygen (O2) dynamics
## in a river

#==================#
# Model equations  #
#==================#
O2BOD &lt;- function(t, state, pars) {

  BOD &lt;- state[1:N]
  O2  &lt;- state[(N+1):(2*N)]

# BOD dynamics
  FluxBOD &lt;-  v * c(BOD_0, BOD)  # fluxes due to water transport
  FluxO2  &lt;-  v * c(O2_0, O2)
  
  BODrate &lt;- r*BOD*O2/(O2+10)  # 1-st order consumption, Monod in oxygen

#rate of change = flux gradient - consumption  + reaeration (O2)
  dBOD         &lt;- -diff(FluxBOD)/dx  - BODrate
  dO2          &lt;- -diff(FluxO2)/dx   - BODrate + p*(O2sat-O2)

  return(list(c(dBOD = dBOD, dO2 = dO2), BODrate = BODrate))

}    # END O2BOD
 
 
#==================#
# Model application#
#==================#
# parameters
dx      &lt;- 100       # grid size, meters
v       &lt;- 1e2       # velocity, m/day
x       &lt;- seq(dx/2, 10000, by = dx)  # m, distance from river
N       &lt;- length(x)
r       &lt;- 0.1       # /day, first-order decay of BOD
p       &lt;- 0.1       # /day, air-sea exchange rate
O2sat   &lt;- 300       # mmol/m3 saturated oxygen conc
O2_0    &lt;- 50        # mmol/m3 riverine oxygen conc
BOD_0   &lt;- 1500      # mmol/m3 riverine BOD concentration

# initial guess:
state &lt;- c(rep(200, N), rep(200, N))

# running the model
print(system.time(
 out   &lt;- steady.1D (y = state, func = O2BOD, parms = NULL,
                     nspec = 2, pos = TRUE, names = c("BOD", "O2"))))

#==================#
# Plotting output  #
#==================#
mf &lt;- par(mfrow = c(2, 2))
plot(x, out$y[ ,"O2"], xlab =  "Distance from river",
     ylab = "mmol/m3", main = "Oxygen", type = "l")

plot(x, out$y[ ,"BOD"], xlab = "Distance from river",
     ylab = "mmol/m3", main = "BOD", type = "l")

plot(x, out$BODrate, xlab = "Distance from river",
     ylab = "mmol/m3/d", main = "BOD decay rate", type = "l")
par(mfrow=mf)

# same plot in one command
plot(out, which = c("O2","BOD","BODrate"),xlab = "Distance from river",
     ylab = c("mmol/m3","mmol/m3","mmol/m3/d"), 
     main = c("Oxygen","BOD","BOD decay rate"), type = "l")

# same, but now running dynamically to steady-state
print(system.time(
out2 &lt;- steady.1D (y = state, func = O2BOD, parms = NULL, nspec = 2,
                   time = c(0, 1000), method = "runsteady", 
                   names = c("BOD", "O2"))))
                    
# plot all state variables at once, against "x":
plot(out2, grid=x, xlab = "Distance from river",
     ylab = "mmol/m3", type = "l", lwd = 2)
                         
plot(out, out2, grid=x, xlab = "Distance from river", which = "BODrate",
     ylab = "mmol/m3", type = "l", lwd = 2)

## =======================================================================
##   EXAMPLE 2: Silicate diagenesis                      
## =======================================================================
## Example from the book:
## Soetaert and Herman (2009).
## a practical guide to ecological modelling -
## using R as a simulation platform.
## Springer

#====================#
# Model equations    #
#====================#

SiDIAmodel &lt;- function (time = 0,    # time, not used here
                        Conc,        # concentrations: BSi, DSi
                        parms = NULL) # parameter values; not used
{
 BSi&lt;- Conc[1:N]
 DSi&lt;- Conc[(N+1):(2*N)]

# transport           
# diffusive fluxes at upper interface of each layer

# upper concentration imposed (bwDSi), lower: zero gradient
 DSiFlux &lt;- -SedDisp *   IntPor *diff(c(bwDSi ,DSi,DSi[N]))/thick    
 BSiFlux &lt;- -Db      *(1-IntPor)*diff(c(BSi[1],BSi,BSi[N]))/thick 

 BSiFlux[1] &lt;- BSidepo                # upper boundary flux is imposed

# BSi dissolution     
 Dissolution &lt;- rDissSi * BSi*(1.- DSi/EquilSi )^pow 
 Dissolution &lt;- pmax(0,Dissolution)

# Rate of change= Flux gradient, corrected for porosity + dissolution
 dDSi     &lt;- -diff(DSiFlux)/thick/Porosity      +    # transport
              Dissolution * (1-Porosity)/Porosity    # biogeochemistry

 dBSi     &lt;- -diff(BSiFlux)/thick/(1-Porosity)  - Dissolution				

 return(list(c(dBSi, dDSi),           # Rates of changes
        Dissolution = Dissolution,    # Profile of dissolution rates
        DSiSurfFlux = DSiFlux[1],     # DSi sediment-water exchange rate 
        DSIDeepFlux = DSiFlux[N+1],   # DSi deep-water (burial) flux
        BSiDeepFlux = BSiFlux[N+1]))  # BSi deep-water (burial) flux
}

#====================#
# Model run          #
#====================#
# sediment parameters
thick    &lt;- 0.1                       # thickness of sediment layers (cm)
Intdepth &lt;- seq(0, 10, by = thick)    # depth at upper interface of layers
Nint     &lt;- length(Intdepth)          # number of interfaces
Depth    &lt;- 0.5*(Intdepth[-Nint] +Intdepth[-1]) # depth at middle of layers
N        &lt;- length(Depth)                       # number of layers

por0    &lt;- 0.9                         # surface porosity (-)
pordeep &lt;- 0.7                         # deep porosity    (-)
porcoef &lt;- 2                           # porosity decay coefficient  (/cm)
# porosity profile, middle of layers
Porosity &lt;- pordeep + (por0-pordeep)*exp(-Depth*porcoef)    
# porosity profile, upper interface 
IntPor   &lt;- pordeep + (por0-pordeep)*exp(-Intdepth*porcoef)  

dB0      &lt;- 1/365           # cm2/day      - bioturbation coefficient
dBcoeff  &lt;- 2
mixdepth &lt;- 5               # cm
Db       &lt;- pmin(dB0, dB0*exp(-(Intdepth-mixdepth)*dBcoeff))

# biogeochemical parameters
SedDisp  &lt;- 0.4             # diffusion coefficient, cm2/d
rDissSi  &lt;- 0.005           # dissolution rate, /day
EquilSi  &lt;- 800             # equilibrium concentration
pow      &lt;- 1
BSidepo  &lt;- 0.2*100         # nmol/cm2/day
bwDSi    &lt;- 150             # mmol/m3

# initial guess of state variables-just random numbers between 0,1
Conc     &lt;- runif(2*N)

# three runs with different deposition rates                                      
BSidepo  &lt;- 0.2*100          # nmol/cm2/day
sol  &lt;- steady.1D (Conc, func = SiDIAmodel, parms = NULL, nspec = 2, 
                   names = c("DSi", "BSi"))

BSidepo  &lt;- 2*100          # nmol/cm2/day
sol2 &lt;- steady.1D (Conc, func = SiDIAmodel, parms = NULL, nspec = 2, 
                   names = c("DSi", "BSi"))

BSidepo  &lt;- 3*100          # nmol/cm2/day
sol3 &lt;- steady.1D (Conc, func = SiDIAmodel, parms = NULL, nspec = 2, 
                   names = c("DSi", "BSi"))

#====================#
# plotting output    #
#====================#
par(mfrow=c(2,2))

# Plot 3 runs 
plot(sol, sol2, sol3, xyswap = TRUE, mfrow = c(2, 2),
     xlab = c("mmolSi/m3 liquid", "mmolSi/m3 solid"), 
     ylab = "Depth", lwd = 2, lty = 1)
legend("bottom", c("0.2", "2", "3"), title = "mmol/m2/d",
       lwd = 2, col = 1:3)
plot(Porosity, Depth, ylim = c(10, 0), xlab = "-" ,
     main = "Porosity",    type = "l", lwd = 2)
plot(Db, Intdepth, ylim = c(10, 0), xlab = "cm2/d",
     main = "Bioturbation", type = "l", lwd = 2)
mtext(outer = TRUE, side = 3, line = -2, cex = 1.5, "SiDIAmodel")

# similar, but shorter
plot(sol, sol2, sol3, vertical =TRUE,
     lwd = 2, lty = 1,
     main = c("DSi [mmol/m3 liq]","BSi [mmol/m3 sol]"),
     ylab= "depth [cm]")
legend("bottom", c("0.2", "2", "3"), title = "mmol/m2/d",
       lwd = 2, col = 1:3)


</pre>

<hr /><div style="text-align: center;">[Package <em>rootSolve</em> version 1.8.1 <a href="00Index.html">Index</a>]</div>
</body></html>
