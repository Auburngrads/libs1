<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Plot and Summary Method for steady1D, steady2D and steady3D...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for plot.steady1D {rootSolve}"><tr><td>plot.steady1D {rootSolve}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>
Plot and Summary Method for steady1D, steady2D and steady3D Objects
</h2>

<h3>Description</h3>

<p>Plot the output of steady-state solver routines.
</p>


<h3>Usage</h3>

<pre>
## S3 method for class 'steady1D'
plot(x, ..., which = NULL, grid = NULL, 
              xyswap = FALSE, ask = NULL, 
              obs = NULL, obspar = list(), vertical = FALSE)
## S3 method for class 'steady2D'
image(x, which = NULL, add.contour = FALSE, 
              grid = NULL, ask = NULL, 
              method = "image", legend = FALSE, ...)
## S3 method for class 'steady2D'
subset(x, which = NULL, ...)
## S3 method for class 'steady3D'
image(x, which = NULL, dimselect = NULL, 
              add.contour = FALSE, grid = NULL, ask = NULL, 
              method = "image", legend = FALSE, ...)
## S3 method for class 'rootSolve'
summary(object, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x </code></td>
<td>
<p>an object of class <code>steady1D</code>, or <code>steady2D</code> as 
returned by the solvers <code>steady.1D</code> and <code>steady.2D</code>, and 
to be plotted.
</p>
<p>For <code>steady1D</code> objects, it is allowed to pass several objects 
after <code>x</code> (unnamed) - see second example.
</p>
</td></tr>
<tr valign="top"><td><code>which </code></td>
<td>
<p>the name(s) or the index to the variables that should be
plotted.  Default = all variables. </p>
</td></tr>
<tr valign="top"><td><code>grid </code></td>
<td>
<p>For 1-D plots of output generated with <code>steady.1D</code>, 
a vector of values against which the 1-D steady-state solution 
has to be plotted. If <code>NULL</code>, then steady-state solutions 
are plotted against the index. 
</p>
<p>for <code>image</code> plots of output generated with <code>steady.2D</code> or 
<code>steady.3D</code>: the x- and y-grid, as a <code>list</code>.</p>
</td></tr>
<tr valign="top"><td><code>ask </code></td>
<td>
<p>logical; if <code>TRUE</code>, the user is <em>ask</em>ed before
each plot, if <code>NULL</code> the user is only asked if more than one
page of plots is necessary and the current graphics device is set
interactive, see <code><a href="../../graphics/html/par.html">par</a>(ask=.)</code> and
<code><a href="../../grDevices/html/dev.interactive.html">dev.interactive</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>xyswap </code></td>
<td>
<p>if <code>TRUE</code>, then x-and y-values are swapped and the 
y-axis is from top to bottom. Useful for drawing vertical profiles.</p>
</td></tr>
<tr valign="top"><td><code>vertical </code></td>
<td>
<p>if <code>TRUE</code>, then 1. x-and y-values are swapped, the
y-axis is from top to bottom, the x-axis is on top, margin 3 and the
main title gets the value of the x-axis.
Useful for drawing vertical profiles; see example 2.</p>
</td></tr>
<tr valign="top"><td><code>obs </code></td>
<td>
<p>a <code>data.frame</code> or <code>matrix</code> with &quot;observed data&quot; that
will be added as <code>points</code> to the plots. <code>obs</code> can also be a 
<code>list</code> with multiple data.frames and/or matrices containing 
observed data. 
</p>
<p>The first column of <code>obs</code> should contain the grid-variables as 
specified in argument <code>grid</code>. 
The other columns contain the observed values
and they should have names that are known in <code>x</code>.    
</p>
<p>If the first column of <code>obs</code> consists of factors, or characters (strings),
then it is assumed that the data are presented in long (database) format,
where the first three columns contain (name, grid, value).  
</p>
<p>If <code>obs</code> is not <code>NULL</code> and 
<code>which</code> is <code>NULL</code>, then the variables, common to both 
<code>obs</code> and <code>x</code> will be plotted.
</p>
</td></tr>
<tr valign="top"><td><code>obspar </code></td>
<td>
<p>additional graphics arguments passed to <code>points</code>, for 
plotting the observed data. If <code>obs</code> is a <code>list</code> containing multiple
observed data sets, then the graphics arguments can be  a vector
or a list (e.g. for <code>xlim</code>, <code>ylim</code>), specifying each data set 
separately.
</p>
</td></tr>
<tr valign="top"><td><code>dimselect </code></td>
<td>
<p>a <code>list</code> or <code>NULL</code>. The dimension over which the 
3-D image loops.  If <code>NULL</code>, will loop over the 3rd (z) dimension. This is
similar as setting <code>dimselect = list(z = 1:Nz)</code> where Nz is the number
of grid cells in the 3rd dimension; setting 
<code>dimselect = list(z = seq(1, Nz, by =2))</code> will loop over the 3rd dimension,
but every 2nd cell; <code>dimselect = list(x = ...)</code> or <code>dimselect = list(y = ...)</code>
will loop over the x respectively y-dimension. See <code><a href="steady.3D.html">steady.3D</a></code>
for some examples. 
</p>
</td></tr>
<tr valign="top"><td><code>add.contour </code></td>
<td>
<p>if <code>TRUE</code>, will add contours to the image plot. </p>
</td></tr>
<tr valign="top"><td><code>method </code></td>
<td>
<p>the name of the plotting function to use, one of &quot;image&quot;, 
&quot;filled.contour&quot;, &quot;contour&quot; or &quot;persp&quot;.</p>
</td></tr>
<tr valign="top"><td><code>legend </code></td>
<td>
<p>if <code>TRUE</code>, a color legend will be drawn next to 
the &quot;image&quot;, or &quot;persp&quot; plot.</p>
</td></tr>
<tr valign="top"><td><code>object </code></td>
<td>
<p>object of class <code>rootSolve</code> whose summary has to be 
calculated.
</p>
</td></tr> 
<tr valign="top"><td><code>...</code></td>
<td>
<p>additional arguments passed to the methods.
</p>
<p>The graphical arguments are passed to
<code><a href="../../graphics/html/plot.default.html">plot.default</a></code> (for 1D) or <code>image</code> (for 2D, 3D)
</p>
<p>For <code>plot.steady1D</code>, the dots may contain other objects of class 
<code>steady1D</code>, as returned by <code>steady.1D</code>, and 
to be plotted on the same graphs as <code>x</code>  - see second example.
<code>x</code> and and these other objects should be compatible, 
i.e. the column names should be the same.
</p>
<p>For <code>plot.steady1D</code>, the arguments after ... must be matched exactly.     
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of panels per page is automatically determined up to 3 x 3
(<code>par(mfrow=c(3, 3))</code>). This default can be overwritten by
specifying user-defined settings for <code>mfrow</code> or <code>mfcol</code>.
Set <code>mfrow</code> equal to <code>NULL</code> to avoid the plotting function to 
change user-defined <code>mfrow</code> or <code>mfcol</code> settings
</p>
<p>Other graphical parameters can be passed as well. Parameters
are vectorized, either according to the number of plots 
(<code>xlab, ylab</code>, <code>main, sub</code>, <code>xlim, ylim</code>, <code>log</code>,
<code>asp, ann, axes, frame.plot</code>,<code>panel.first,panel.last</code>,
<code>cex.lab,cex.axis,cex.main</code>) or 
according to the number of lines within one plot (other parameters 
e.g. <code>col</code>, <code>lty</code>, <code>lwd</code> etc.) so it is possible to
assign specific axis labels to individual plots, resp. different plotting 
style. Plotting parameter <code>ylim</code>, or <code>xlim</code> can also be a list 
to assign different axis limits to individual plots.
</p>
<p>Similarly, the graphical parameters for observed data, as passed by 
<code>obspar</code> can be vectorized, according to the number of observed 
data sets.
</p>
<p>For <code>steady3D</code> objects, 2-D images are generated by looping over
one of the axies; by default the third axis. See  <code><a href="steady.3D.html">steady.3D</a></code>. 
</p>


<h3>See Also</h3>

<p><code><a href="steady.1D.html">steady.1D</a></code>, <code><a href="steady.2D.html">steady.2D</a></code>, <code><a href="steady.3D.html">steady.3D</a></code>  
</p>


<h3>Examples</h3>

<pre>
## =======================================================================
##  EXAMPLE 1: 1D model, BOD + O2                                
## =======================================================================
## Biochemical Oxygen Demand (BOD) and oxygen (O2) dynamics
## in a river

#==================#
# Model equations  #
#==================#
O2BOD &lt;- function(t, state, pars) {
  BOD &lt;- state[1:N]
  O2  &lt;- state[(N+1):(2*N)]

# BOD dynamics
  FluxBOD &lt;-  v * c(BOD_0, BOD)  # fluxes due to water transport
  FluxO2  &lt;-  v * c(O2_0, O2)
  
  BODrate &lt;- r*BOD*O2/(O2+10)  # 1-st order consumption, Monod in oxygen

#rate of change = flux gradient - consumption  + reaeration (O2)
  dBOD         &lt;- -diff(FluxBOD)/dx  - BODrate
  dO2          &lt;- -diff(FluxO2)/dx   - BODrate + p*(O2sat-O2)

  return(list(c(dBOD = dBOD, dO2 = dO2)))
}    # END O2BOD
 
 
#==================#
# Model application#
#==================#
# parameters
dx      &lt;- 100       # grid size, meters
v       &lt;- 1e2       # velocity, m/day
x       &lt;- seq(dx/2,10000,by=dx)  # m, distance from river
N       &lt;- length(x)
r       &lt;- 0.1       # /day, first-order decay of BOD
p       &lt;- 0.1       # /day, air-sea exchange rate
O2sat   &lt;- 300       # mmol/m3 saturated oxygen conc
O2_0    &lt;- 50        # mmol/m3 riverine oxygen conc
BOD_0   &lt;- 1500      # mmol/m3 riverine BOD concentration

# initial guess:
state &lt;- c(rep(200,N), rep(200,N))

# running the model
out   &lt;- steady.1D (y = state, func = O2BOD, parms = NULL,
                    nspec = 2, pos = TRUE, 
                    names = c("BOD", "O2"))

summary(out)

# output
plot(out, grid = x, type = "l", lwd = 2, 
     ylab = c("mmol/m3", "mmol O2/m3"))

# observations
obs &lt;- matrix (ncol = 2, data = c(seq(0, 10000, 2000),
                                c(1400, 900,400,100,10,10)))

colnames(obs) &lt;- c("Distance", "BOD")

# plot with observations
plot(out, grid = x, type = "l", lwd = 2, ylab = "mmol/m3", obs = obs, 
     pch = 16, cex = 1.5)

# similar but data in "long" format
OUT &lt;- data.frame(name = "BOD", obs)
## Not run: 
plot(out, grid = x, type = "l", lwd = 2, ylab = "mmol/m3", obs = OBS, 
     pch = 16, cex = 1.5)

## End(Not run)

## =======================================================================
##  EXAMPLE 2: 1D model, BOD + O2 - second run                               
## =======================================================================
# new runs with different v
v       &lt;- 50       # velocity, m/day

# running the model a second time
out2   &lt;- steady.1D (y = state, func = O2BOD, parms = NULL,
                     nspec = 2, pos = TRUE, names = c("BOD", "O2"))


v       &lt;- 200       # velocity, m/day

# running the model a second time
out3   &lt;- steady.1D (y = state, func = O2BOD, parms = NULL,
                     nspec = 2, pos = TRUE, names = c("BOD", "O2"))

# output of all three scenarios at once
plot(out, out2, out3, type = "l", lwd = 2, 
     ylab = c("mmol/m3", "mmol O2/m3"), grid = x,
     obs = obs, which = c("BOD", "O2"))
  
# output of all three scenarios at once, and using vertical style
plot(out, out2, out3, type = "l", lwd = 2, vertical = TRUE,
     ylab = "Distance [m]",
     main = c("BOD [mmol/m3]", "O2 [mmol O2/m3]"), grid = x,
     obs = obs, which = c("BOD", "O2"))

# change plot pars
plot(out, out2, out3, type = "l", lwd = 2, 
     ylab = c("mmol/m3", "mmol O2/m3"), 
     grid = x, col = c("blue", "green"), log = "y",  
     obs = obs, obspar = list(pch = 16, col = "red", cex = 2))

## =======================================================================
## EXAMPLE 3: Diffusion in 2-D; zero-gradient boundary conditions
## =======================================================================

diffusion2D &lt;- function(t,Y,par)  {
   y    &lt;- matrix(nr=n,nc=n,data=Y)  # vector to 2-D matrix
   dY   &lt;- -r*y        # consumption
   BND   &lt;- rep(1,n)   # boundary concentration 

   #diffusion in X-direction; boundaries=imposed concentration
   Flux &lt;- -Dx * rbind(y[1,]-BND, (y[2:n,]-y[1:(n-1),]), BND-y[n,])/dx
   dY   &lt;- dY - (Flux[2:(n+1),]-Flux[1:n,])/dx

   #diffusion in Y-direction
   Flux &lt;- -Dy * cbind(y[,1]-BND, (y[,2:n]-y[,1:(n-1)]), BND-y[,n])/dy
   dY    &lt;- dY - (Flux[ ,2:(n+1)]-Flux[ ,1:n])/dy
                                              
   return(list(as.vector(dY)))
}

  # parameters
dy    &lt;- dx &lt;- 1   # grid size
Dy    &lt;- Dx &lt;- 1   # diffusion coeff, X- and Y-direction
r     &lt;- 0.025     # consumption rate

n  &lt;- 100
Y  &lt;- matrix(nrow = n, ncol = n, 10.)

ST &lt;- steady.2D(Y, func = diffusion2D, parms = NULL, pos = TRUE,
                dimens = c(n, n), lrw = 1000000,
                atol = 1e-10, rtol = 1e-10, ctol = 1e-10)
grid &lt;- list(x = seq(dx/2, by = dx, length.out = n), 
             y = seq(dy/2, by = dy, length.out = n))
image(ST, grid = grid)
summary(ST)
</pre>

<hr /><div style="text-align: center;">[Package <em>rootSolve</em> version 1.8.1 <a href="00Index.html">Index</a>]</div>
</body></html>
