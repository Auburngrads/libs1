<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Finds many (all) roots of one equation within an interval</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for uniroot.all {rootSolve}"><tr><td>uniroot.all {rootSolve}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>
Finds many (all) roots of one equation within an interval
</h2>

<h3>Description</h3>

<p>The function <code>uniroot.all</code> searches the interval from lower to upper
for several roots (i.e., zero's) of a function <code>f</code> with respect to
its first argument.
</p>


<h3>Usage</h3>

<pre>
uniroot.all(f, interval, lower = min(interval), upper = max(interval), 
            tol = .Machine$double.eps^0.2, maxiter = 1000, 
            trace = 0, n = 100, ...)</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>f </code></td>
<td>
<p>the function for which the root is sought.
</p>
</td></tr>
<tr valign="top"><td><code>interval </code></td>
<td>
<p>a vector containing the end-points of the interval to
be searched for the root.
</p>
</td></tr>
<tr valign="top"><td><code>lower </code></td>
<td>
<p>the lower end point of the interval to be searched.
</p>
</td></tr>
<tr valign="top"><td><code>upper </code></td>
<td>
<p>the upper end point of the interval to be searched.
</p>
</td></tr>
<tr valign="top"><td><code>tol </code></td>
<td>
<p>the desired accuracy (convergence tolerance).  Passed to function <a href="../../stats/html/uniroot.html">uniroot</a>
</p>
</td></tr>
<tr valign="top"><td><code>maxiter </code></td>
<td>
<p>the maximum number of iterations.  Passed to function <a href="../../stats/html/uniroot.html">uniroot</a>
</p>
</td></tr>
<tr valign="top"><td><code>trace </code></td>
<td>
<p>integer number; if positive, tracing information is produced. 
Higher values giving more details. Passed to function <a href="../../stats/html/uniroot.html">uniroot</a></p>
</td></tr>
<tr valign="top"><td><code>n </code></td>
<td>
<p>number of subintervals in which the root is sought.
</p>
</td></tr>
<tr valign="top"><td><code>... </code></td>
<td>
<p>additional named or unnamed arguments to be passed to <code>f</code>
(but beware of partial matching to other arguments).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>f</code> will be called as <code>f(x, ...)</code> for a numeric value of <code>x</code>.
</p>
<p>Run <code>demo(Jacobandroots)</code> for an example of the use of <code>uniroot.all</code>
for steady-state analysis.
</p>
<p>See also second example of <code><a href="gradient.html">gradient</a></code>
This example is discussed in the book by Soetaert and Herman (2009).
</p>


<h3>Value</h3>

<p>a vector with the roots found in the interval
</p>


<h3>Note</h3>

<p>The function calls <code>uniroot</code>, the basic R-function.
</p>
<p>It is not guaranteed that all roots will be recovered.
</p>
<p>This will depend on <code>n</code>, the number of subintervals in which the
interval is divided.
</p>
<p>If the function &quot;touches&quot; the X-axis (i.e. the root is a saddle point),
then this root will generally not be retrieved.
(but chances of this are pretty small).
</p>
<p>Whereas <code>unitroot</code> passes values one at a time to the function,
<code>uniroot.all</code> passes a vector of values to the function. 
Therefore <code>f</code> should be written such that it can handle a vector of values.
See last example.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>See Also</h3>

<p><code><a href="../../stats/html/uniroot.html">uniroot</a></code> for more information about input.
</p>


<h3>Examples</h3>

<pre>
## =======================================================================
##   Mathematical examples  
## =======================================================================

# a well-behaved case...
fun &lt;- function (x) cos(2*x)^3

curve(fun(x), 0, 10,main = "uniroot.all")

All &lt;- uniroot.all(fun, c(0, 10))
points(All, y = rep(0, length(All)), pch = 16, cex = 2)

# a difficult case...
f &lt;- function (x) 1/cos(1+x^2)
AA &lt;- uniroot.all(f, c(-5, 5))
curve(f(x), -5, 5, n = 500, main = "uniroot.all")
points(AA, rep(0, length(AA)), col = "red", pch = 16)

f(AA)  # !!!

## =======================================================================
## Ecological modelling example  
## =======================================================================

# Example from the book of Soetaert and Herman(2009)
# A practical guide to ecological modelling -
# using R as a simulation platform. Springer

r   &lt;- 0.05
K   &lt;- 10
bet &lt;- 0.1
alf &lt;- 1

# the model : density-dependent growth and sigmoid-type mortality rate
rate &lt;- function(x, r = 0.05) r*x*(1-x/K) - bet*x^2/(x^2+alf^2)

# find all roots within the interval [0,10]
Eq   &lt;- uniroot.all(rate, c(0, 10))

# jacobian evaluated at all roots: 
# This is just one value - and therefore jacobian = eigenvalue
# the sign of eigenvalue: stability of the root: neg=stable, 0=saddle, pos=unstable

eig &lt;- vector()
for (i in 1:length(Eq)) 
  eig[i] &lt;- sign (gradient(rate, Eq[i]))

curve(rate(x), ylab = "dx/dt", from = 0, to = 10,
      main = "Budworm model, roots", 
      sub = "Example from Soetaert and Herman, 2009")
abline(h = 0)
points(x = Eq, y = rep(0, length(Eq)), pch = 21, cex = 2,
       bg = c("grey", "black", "white")[eig+2] )
legend("topleft", pch = 22, pt.cex = 2,
       c("stable", "saddle", "unstable"),
       col = c("grey", "black", "white"), 
       pt.bg = c("grey", "black", "white"))
       
## =======================================================================
## Vectorisation:
## =======================================================================
# from R-help Digest, Vol 130, Issue 27
#https://stat.ethz.ch/pipermail/r-help/2013-December/364799.html

integrand1 &lt;- function(x) 1/x*dnorm(x) 
integrand2 &lt;- function(x) 1/(2*x-50)*dnorm(x) 
integrand3 &lt;- function(x, C) 1/(x+C)

res &lt;- function(C) {
  integrate(integrand1, lower = 1, upper = 50)$value + 
  integrate(integrand2, lower = 50, upper = 100)$value - 
  integrate(integrand3, C = C, lower = 1, upper = 100)$value
}

# uniroot passes one value at a time to the function, so res can be used as such
uniroot(res, c(1, 1000))

# Need to vectorise the function to use uniroot.all:
res &lt;- Vectorize(res)
uniroot.all(res, c(1,1000))
       
</pre>

<hr /><div style="text-align: center;">[Package <em>rootSolve</em> version 1.8.1 <a href="00Index.html">Index</a>]</div>
</body></html>
